// Package strava provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package strava

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Strava_oauthScopes = "strava_oauth.Scopes"
)

// Defines values for ActivityType.
const (
	ActivityTypeAlpineSki       ActivityType = "AlpineSki"
	ActivityTypeBackcountrySki  ActivityType = "BackcountrySki"
	ActivityTypeCanoeing        ActivityType = "Canoeing"
	ActivityTypeCrossfit        ActivityType = "Crossfit"
	ActivityTypeEBikeRide       ActivityType = "EBikeRide"
	ActivityTypeElliptical      ActivityType = "Elliptical"
	ActivityTypeGolf            ActivityType = "Golf"
	ActivityTypeHandcycle       ActivityType = "Handcycle"
	ActivityTypeHike            ActivityType = "Hike"
	ActivityTypeIceSkate        ActivityType = "IceSkate"
	ActivityTypeInlineSkate     ActivityType = "InlineSkate"
	ActivityTypeKayaking        ActivityType = "Kayaking"
	ActivityTypeKitesurf        ActivityType = "Kitesurf"
	ActivityTypeNordicSki       ActivityType = "NordicSki"
	ActivityTypeRide            ActivityType = "Ride"
	ActivityTypeRockClimbing    ActivityType = "RockClimbing"
	ActivityTypeRollerSki       ActivityType = "RollerSki"
	ActivityTypeRowing          ActivityType = "Rowing"
	ActivityTypeRun             ActivityType = "Run"
	ActivityTypeSail            ActivityType = "Sail"
	ActivityTypeSkateboard      ActivityType = "Skateboard"
	ActivityTypeSnowboard       ActivityType = "Snowboard"
	ActivityTypeSnowshoe        ActivityType = "Snowshoe"
	ActivityTypeSoccer          ActivityType = "Soccer"
	ActivityTypeStairStepper    ActivityType = "StairStepper"
	ActivityTypeStandUpPaddling ActivityType = "StandUpPaddling"
	ActivityTypeSurfing         ActivityType = "Surfing"
	ActivityTypeSwim            ActivityType = "Swim"
	ActivityTypeVelomobile      ActivityType = "Velomobile"
	ActivityTypeVirtualRide     ActivityType = "VirtualRide"
	ActivityTypeVirtualRun      ActivityType = "VirtualRun"
	ActivityTypeWalk            ActivityType = "Walk"
	ActivityTypeWeightTraining  ActivityType = "WeightTraining"
	ActivityTypeWheelchair      ActivityType = "Wheelchair"
	ActivityTypeWindsurf        ActivityType = "Windsurf"
	ActivityTypeWorkout         ActivityType = "Workout"
	ActivityTypeYoga            ActivityType = "Yoga"
)

// Defines values for BaseStreamResolution.
const (
	BaseStreamResolutionHigh   BaseStreamResolution = "high"
	BaseStreamResolutionLow    BaseStreamResolution = "low"
	BaseStreamResolutionMedium BaseStreamResolution = "medium"
)

// Defines values for BaseStreamSeriesType.
const (
	BaseStreamSeriesTypeDistance BaseStreamSeriesType = "distance"
	BaseStreamSeriesTypeTime     BaseStreamSeriesType = "time"
)

// Defines values for DetailedAthleteMeasurementPreference.
const (
	Feet   DetailedAthleteMeasurementPreference = "feet"
	Meters DetailedAthleteMeasurementPreference = "meters"
)

// Defines values for DetailedAthleteSex.
const (
	DetailedAthleteSexF DetailedAthleteSex = "F"
	DetailedAthleteSexM DetailedAthleteSex = "M"
)

// Defines values for DetailedClubMembership.
const (
	Member  DetailedClubMembership = "member"
	Pending DetailedClubMembership = "pending"
)

// Defines values for DetailedClubSportType.
const (
	DetailedClubSportTypeCycling   DetailedClubSportType = "cycling"
	DetailedClubSportTypeOther     DetailedClubSportType = "other"
	DetailedClubSportTypeRunning   DetailedClubSportType = "running"
	DetailedClubSportTypeTriathlon DetailedClubSportType = "triathlon"
)

// Defines values for DetailedSegmentActivityType.
const (
	DetailedSegmentActivityTypeRide DetailedSegmentActivityType = "Ride"
	DetailedSegmentActivityTypeRun  DetailedSegmentActivityType = "Run"
)

// Defines values for StreamSetAltitudeResolution.
const (
	StreamSetAltitudeResolutionHigh   StreamSetAltitudeResolution = "high"
	StreamSetAltitudeResolutionLow    StreamSetAltitudeResolution = "low"
	StreamSetAltitudeResolutionMedium StreamSetAltitudeResolution = "medium"
)

// Defines values for StreamSetAltitudeSeriesType.
const (
	StreamSetAltitudeSeriesTypeDistance StreamSetAltitudeSeriesType = "distance"
	StreamSetAltitudeSeriesTypeTime     StreamSetAltitudeSeriesType = "time"
)

// Defines values for StreamSetCadenceResolution.
const (
	StreamSetCadenceResolutionHigh   StreamSetCadenceResolution = "high"
	StreamSetCadenceResolutionLow    StreamSetCadenceResolution = "low"
	StreamSetCadenceResolutionMedium StreamSetCadenceResolution = "medium"
)

// Defines values for StreamSetCadenceSeriesType.
const (
	StreamSetCadenceSeriesTypeDistance StreamSetCadenceSeriesType = "distance"
	StreamSetCadenceSeriesTypeTime     StreamSetCadenceSeriesType = "time"
)

// Defines values for StreamSetDistanceResolution.
const (
	StreamSetDistanceResolutionHigh   StreamSetDistanceResolution = "high"
	StreamSetDistanceResolutionLow    StreamSetDistanceResolution = "low"
	StreamSetDistanceResolutionMedium StreamSetDistanceResolution = "medium"
)

// Defines values for StreamSetDistanceSeriesType.
const (
	StreamSetDistanceSeriesTypeDistance StreamSetDistanceSeriesType = "distance"
	StreamSetDistanceSeriesTypeTime     StreamSetDistanceSeriesType = "time"
)

// Defines values for StreamSetGradeSmoothResolution.
const (
	StreamSetGradeSmoothResolutionHigh   StreamSetGradeSmoothResolution = "high"
	StreamSetGradeSmoothResolutionLow    StreamSetGradeSmoothResolution = "low"
	StreamSetGradeSmoothResolutionMedium StreamSetGradeSmoothResolution = "medium"
)

// Defines values for StreamSetGradeSmoothSeriesType.
const (
	StreamSetGradeSmoothSeriesTypeDistance StreamSetGradeSmoothSeriesType = "distance"
	StreamSetGradeSmoothSeriesTypeTime     StreamSetGradeSmoothSeriesType = "time"
)

// Defines values for StreamSetHeartrateResolution.
const (
	StreamSetHeartrateResolutionHigh   StreamSetHeartrateResolution = "high"
	StreamSetHeartrateResolutionLow    StreamSetHeartrateResolution = "low"
	StreamSetHeartrateResolutionMedium StreamSetHeartrateResolution = "medium"
)

// Defines values for StreamSetHeartrateSeriesType.
const (
	StreamSetHeartrateSeriesTypeDistance StreamSetHeartrateSeriesType = "distance"
	StreamSetHeartrateSeriesTypeTime     StreamSetHeartrateSeriesType = "time"
)

// Defines values for StreamSetLatlngResolution.
const (
	StreamSetLatlngResolutionHigh   StreamSetLatlngResolution = "high"
	StreamSetLatlngResolutionLow    StreamSetLatlngResolution = "low"
	StreamSetLatlngResolutionMedium StreamSetLatlngResolution = "medium"
)

// Defines values for StreamSetLatlngSeriesType.
const (
	StreamSetLatlngSeriesTypeDistance StreamSetLatlngSeriesType = "distance"
	StreamSetLatlngSeriesTypeTime     StreamSetLatlngSeriesType = "time"
)

// Defines values for StreamSetMovingResolution.
const (
	StreamSetMovingResolutionHigh   StreamSetMovingResolution = "high"
	StreamSetMovingResolutionLow    StreamSetMovingResolution = "low"
	StreamSetMovingResolutionMedium StreamSetMovingResolution = "medium"
)

// Defines values for StreamSetMovingSeriesType.
const (
	StreamSetMovingSeriesTypeDistance StreamSetMovingSeriesType = "distance"
	StreamSetMovingSeriesTypeTime     StreamSetMovingSeriesType = "time"
)

// Defines values for StreamSetTempResolution.
const (
	StreamSetTempResolutionHigh   StreamSetTempResolution = "high"
	StreamSetTempResolutionLow    StreamSetTempResolution = "low"
	StreamSetTempResolutionMedium StreamSetTempResolution = "medium"
)

// Defines values for StreamSetTempSeriesType.
const (
	StreamSetTempSeriesTypeDistance StreamSetTempSeriesType = "distance"
	StreamSetTempSeriesTypeTime     StreamSetTempSeriesType = "time"
)

// Defines values for StreamSetTimeResolution.
const (
	StreamSetTimeResolutionHigh   StreamSetTimeResolution = "high"
	StreamSetTimeResolutionLow    StreamSetTimeResolution = "low"
	StreamSetTimeResolutionMedium StreamSetTimeResolution = "medium"
)

// Defines values for StreamSetTimeSeriesType.
const (
	StreamSetTimeSeriesTypeDistance StreamSetTimeSeriesType = "distance"
	StreamSetTimeSeriesTypeTime     StreamSetTimeSeriesType = "time"
)

// Defines values for StreamSetVelocitySmoothResolution.
const (
	StreamSetVelocitySmoothResolutionHigh   StreamSetVelocitySmoothResolution = "high"
	StreamSetVelocitySmoothResolutionLow    StreamSetVelocitySmoothResolution = "low"
	StreamSetVelocitySmoothResolutionMedium StreamSetVelocitySmoothResolution = "medium"
)

// Defines values for StreamSetVelocitySmoothSeriesType.
const (
	StreamSetVelocitySmoothSeriesTypeDistance StreamSetVelocitySmoothSeriesType = "distance"
	StreamSetVelocitySmoothSeriesTypeTime     StreamSetVelocitySmoothSeriesType = "time"
)

// Defines values for StreamSetWattsResolution.
const (
	StreamSetWattsResolutionHigh   StreamSetWattsResolution = "high"
	StreamSetWattsResolutionLow    StreamSetWattsResolution = "low"
	StreamSetWattsResolutionMedium StreamSetWattsResolution = "medium"
)

// Defines values for StreamSetWattsSeriesType.
const (
	StreamSetWattsSeriesTypeDistance StreamSetWattsSeriesType = "distance"
	StreamSetWattsSeriesTypeTime     StreamSetWattsSeriesType = "time"
)

// Defines values for SummaryAthleteSex.
const (
	SummaryAthleteSexF SummaryAthleteSex = "F"
	SummaryAthleteSexM SummaryAthleteSex = "M"
)

// Defines values for SummaryClubSportType.
const (
	SummaryClubSportTypeCycling   SummaryClubSportType = "cycling"
	SummaryClubSportTypeOther     SummaryClubSportType = "other"
	SummaryClubSportTypeRunning   SummaryClubSportType = "running"
	SummaryClubSportTypeTriathlon SummaryClubSportType = "triathlon"
)

// Defines values for SummarySegmentActivityType.
const (
	SummarySegmentActivityTypeRide SummarySegmentActivityType = "Ride"
	SummarySegmentActivityTypeRun  SummarySegmentActivityType = "Run"
)

// Defines values for UpdateActivityByIdJSONBodySportType.
const (
	UpdateActivityByIdJSONBodySportTypeAlpineSki                     UpdateActivityByIdJSONBodySportType = "AlpineSki"
	UpdateActivityByIdJSONBodySportTypeBackcountrySki                UpdateActivityByIdJSONBodySportType = "BackcountrySki"
	UpdateActivityByIdJSONBodySportTypeBadminton                     UpdateActivityByIdJSONBodySportType = "Badminton"
	UpdateActivityByIdJSONBodySportTypeCanoeing                      UpdateActivityByIdJSONBodySportType = "Canoeing"
	UpdateActivityByIdJSONBodySportTypeCrossfit                      UpdateActivityByIdJSONBodySportType = "Crossfit"
	UpdateActivityByIdJSONBodySportTypeEBikeRide                     UpdateActivityByIdJSONBodySportType = "EBikeRide"
	UpdateActivityByIdJSONBodySportTypeEMountainBikeRide             UpdateActivityByIdJSONBodySportType = "EMountainBikeRide"
	UpdateActivityByIdJSONBodySportTypeElliptical                    UpdateActivityByIdJSONBodySportType = "Elliptical"
	UpdateActivityByIdJSONBodySportTypeGolf                          UpdateActivityByIdJSONBodySportType = "Golf"
	UpdateActivityByIdJSONBodySportTypeGravelRide                    UpdateActivityByIdJSONBodySportType = "GravelRide"
	UpdateActivityByIdJSONBodySportTypeHandcycle                     UpdateActivityByIdJSONBodySportType = "Handcycle"
	UpdateActivityByIdJSONBodySportTypeHighIntensityIntervalTraining UpdateActivityByIdJSONBodySportType = "HighIntensityIntervalTraining"
	UpdateActivityByIdJSONBodySportTypeHike                          UpdateActivityByIdJSONBodySportType = "Hike"
	UpdateActivityByIdJSONBodySportTypeIceSkate                      UpdateActivityByIdJSONBodySportType = "IceSkate"
	UpdateActivityByIdJSONBodySportTypeInlineSkate                   UpdateActivityByIdJSONBodySportType = "InlineSkate"
	UpdateActivityByIdJSONBodySportTypeKayaking                      UpdateActivityByIdJSONBodySportType = "Kayaking"
	UpdateActivityByIdJSONBodySportTypeKitesurf                      UpdateActivityByIdJSONBodySportType = "Kitesurf"
	UpdateActivityByIdJSONBodySportTypeMountainBikeRide              UpdateActivityByIdJSONBodySportType = "MountainBikeRide"
	UpdateActivityByIdJSONBodySportTypeNordicSki                     UpdateActivityByIdJSONBodySportType = "NordicSki"
	UpdateActivityByIdJSONBodySportTypePickleball                    UpdateActivityByIdJSONBodySportType = "Pickleball"
	UpdateActivityByIdJSONBodySportTypePilates                       UpdateActivityByIdJSONBodySportType = "Pilates"
	UpdateActivityByIdJSONBodySportTypeRacquetball                   UpdateActivityByIdJSONBodySportType = "Racquetball"
	UpdateActivityByIdJSONBodySportTypeRide                          UpdateActivityByIdJSONBodySportType = "Ride"
	UpdateActivityByIdJSONBodySportTypeRockClimbing                  UpdateActivityByIdJSONBodySportType = "RockClimbing"
	UpdateActivityByIdJSONBodySportTypeRollerSki                     UpdateActivityByIdJSONBodySportType = "RollerSki"
	UpdateActivityByIdJSONBodySportTypeRowing                        UpdateActivityByIdJSONBodySportType = "Rowing"
	UpdateActivityByIdJSONBodySportTypeRun                           UpdateActivityByIdJSONBodySportType = "Run"
	UpdateActivityByIdJSONBodySportTypeSail                          UpdateActivityByIdJSONBodySportType = "Sail"
	UpdateActivityByIdJSONBodySportTypeSkateboard                    UpdateActivityByIdJSONBodySportType = "Skateboard"
	UpdateActivityByIdJSONBodySportTypeSnowboard                     UpdateActivityByIdJSONBodySportType = "Snowboard"
	UpdateActivityByIdJSONBodySportTypeSnowshoe                      UpdateActivityByIdJSONBodySportType = "Snowshoe"
	UpdateActivityByIdJSONBodySportTypeSoccer                        UpdateActivityByIdJSONBodySportType = "Soccer"
	UpdateActivityByIdJSONBodySportTypeSquash                        UpdateActivityByIdJSONBodySportType = "Squash"
	UpdateActivityByIdJSONBodySportTypeStairStepper                  UpdateActivityByIdJSONBodySportType = "StairStepper"
	UpdateActivityByIdJSONBodySportTypeStandUpPaddling               UpdateActivityByIdJSONBodySportType = "StandUpPaddling"
	UpdateActivityByIdJSONBodySportTypeSurfing                       UpdateActivityByIdJSONBodySportType = "Surfing"
	UpdateActivityByIdJSONBodySportTypeSwim                          UpdateActivityByIdJSONBodySportType = "Swim"
	UpdateActivityByIdJSONBodySportTypeTableTennis                   UpdateActivityByIdJSONBodySportType = "TableTennis"
	UpdateActivityByIdJSONBodySportTypeTennis                        UpdateActivityByIdJSONBodySportType = "Tennis"
	UpdateActivityByIdJSONBodySportTypeTrailRun                      UpdateActivityByIdJSONBodySportType = "TrailRun"
	UpdateActivityByIdJSONBodySportTypeVelomobile                    UpdateActivityByIdJSONBodySportType = "Velomobile"
	UpdateActivityByIdJSONBodySportTypeVirtualRide                   UpdateActivityByIdJSONBodySportType = "VirtualRide"
	UpdateActivityByIdJSONBodySportTypeVirtualRow                    UpdateActivityByIdJSONBodySportType = "VirtualRow"
	UpdateActivityByIdJSONBodySportTypeVirtualRun                    UpdateActivityByIdJSONBodySportType = "VirtualRun"
	UpdateActivityByIdJSONBodySportTypeWalk                          UpdateActivityByIdJSONBodySportType = "Walk"
	UpdateActivityByIdJSONBodySportTypeWeightTraining                UpdateActivityByIdJSONBodySportType = "WeightTraining"
	UpdateActivityByIdJSONBodySportTypeWheelchair                    UpdateActivityByIdJSONBodySportType = "Wheelchair"
	UpdateActivityByIdJSONBodySportTypeWindsurf                      UpdateActivityByIdJSONBodySportType = "Windsurf"
	UpdateActivityByIdJSONBodySportTypeWorkout                       UpdateActivityByIdJSONBodySportType = "Workout"
	UpdateActivityByIdJSONBodySportTypeYoga                          UpdateActivityByIdJSONBodySportType = "Yoga"
)

// Defines values for GetActivityStreamsParamsKeys.
const (
	GetActivityStreamsParamsKeysAltitude       GetActivityStreamsParamsKeys = "altitude"
	GetActivityStreamsParamsKeysCadence        GetActivityStreamsParamsKeys = "cadence"
	GetActivityStreamsParamsKeysDistance       GetActivityStreamsParamsKeys = "distance"
	GetActivityStreamsParamsKeysGradeSmooth    GetActivityStreamsParamsKeys = "grade_smooth"
	GetActivityStreamsParamsKeysHeartrate      GetActivityStreamsParamsKeys = "heartrate"
	GetActivityStreamsParamsKeysLatlng         GetActivityStreamsParamsKeys = "latlng"
	GetActivityStreamsParamsKeysMoving         GetActivityStreamsParamsKeys = "moving"
	GetActivityStreamsParamsKeysTemp           GetActivityStreamsParamsKeys = "temp"
	GetActivityStreamsParamsKeysTime           GetActivityStreamsParamsKeys = "time"
	GetActivityStreamsParamsKeysVelocitySmooth GetActivityStreamsParamsKeys = "velocity_smooth"
	GetActivityStreamsParamsKeysWatts          GetActivityStreamsParamsKeys = "watts"
)

// Defines values for GetSegmentEffortStreamsParamsKeys.
const (
	GetSegmentEffortStreamsParamsKeysAltitude       GetSegmentEffortStreamsParamsKeys = "altitude"
	GetSegmentEffortStreamsParamsKeysCadence        GetSegmentEffortStreamsParamsKeys = "cadence"
	GetSegmentEffortStreamsParamsKeysDistance       GetSegmentEffortStreamsParamsKeys = "distance"
	GetSegmentEffortStreamsParamsKeysGradeSmooth    GetSegmentEffortStreamsParamsKeys = "grade_smooth"
	GetSegmentEffortStreamsParamsKeysHeartrate      GetSegmentEffortStreamsParamsKeys = "heartrate"
	GetSegmentEffortStreamsParamsKeysLatlng         GetSegmentEffortStreamsParamsKeys = "latlng"
	GetSegmentEffortStreamsParamsKeysMoving         GetSegmentEffortStreamsParamsKeys = "moving"
	GetSegmentEffortStreamsParamsKeysTemp           GetSegmentEffortStreamsParamsKeys = "temp"
	GetSegmentEffortStreamsParamsKeysTime           GetSegmentEffortStreamsParamsKeys = "time"
	GetSegmentEffortStreamsParamsKeysVelocitySmooth GetSegmentEffortStreamsParamsKeys = "velocity_smooth"
	GetSegmentEffortStreamsParamsKeysWatts          GetSegmentEffortStreamsParamsKeys = "watts"
)

// Defines values for ExploreSegmentsParamsActivityType.
const (
	Riding  ExploreSegmentsParamsActivityType = "riding"
	Running ExploreSegmentsParamsActivityType = "running"
)

// Defines values for GetSegmentStreamsParamsKeys.
const (
	Altitude GetSegmentStreamsParamsKeys = "altitude"
	Distance GetSegmentStreamsParamsKeys = "distance"
	Latlng   GetSegmentStreamsParamsKeys = "latlng"
)

// Defines values for CreateUploadMultipartBodyDataType.
const (
	Fit   CreateUploadMultipartBodyDataType = "fit"
	FitGz CreateUploadMultipartBodyDataType = "fit.gz"
	Gpx   CreateUploadMultipartBodyDataType = "gpx"
	GpxGz CreateUploadMultipartBodyDataType = "gpx.gz"
	Tcx   CreateUploadMultipartBodyDataType = "tcx"
	TcxGz CreateUploadMultipartBodyDataType = "tcx.gz"
)

// ActivityTotal defines model for ActivityTotal.
type ActivityTotal struct {
	// AchievementCount The total number of achievements of the considered activities.
	AchievementCount *int `json:"achievement_count,omitempty"`

	// Count The number of activities considered in this total.
	Count *int `json:"count,omitempty"`

	// Distance The total distance covered by the considered activities.
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The total elapsed time of the considered activities.
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// ElevationGain The total elevation gain of the considered activities.
	ElevationGain *float32 `json:"elevation_gain,omitempty"`

	// MovingTime The total moving time of the considered activities.
	MovingTime *int `json:"moving_time,omitempty"`
}

// ActivityType An enumeration of the types an activity may have.
type ActivityType string

// BaseStream defines model for BaseStream.
type BaseStream struct {
	// OriginalSize The number of data points in this stream
	OriginalSize *int `json:"original_size,omitempty"`

	// Resolution The level of detail (sampling) in which this stream was returned
	Resolution *BaseStreamResolution `json:"resolution,omitempty"`

	// SeriesType The base series used in the case the stream was downsampled
	SeriesType *BaseStreamSeriesType `json:"series_type,omitempty"`
}

// BaseStreamResolution The level of detail (sampling) in which this stream was returned
type BaseStreamResolution string

// BaseStreamSeriesType The base series used in the case the stream was downsampled
type BaseStreamSeriesType string

// DetailedActivity defines model for DetailedActivity.
type DetailedActivity struct {
	// AchievementCount The number of achievements gained during this activity
	AchievementCount *int         `json:"achievement_count,omitempty"`
	Athlete          *MetaAthlete `json:"athlete,omitempty"`

	// AthleteCount The number of athletes for taking part in a group activity
	AthleteCount *int `json:"athlete_count,omitempty"`

	// AverageSpeed The activity's average speed, in meters per second
	AverageSpeed *float32                 `json:"average_speed,omitempty"`
	BestEfforts  *[]DetailedSegmentEffort `json:"best_efforts,omitempty"`

	// Calories The number of kilocalories consumed during this activity
	Calories *float32 `json:"calories,omitempty"`

	// CommentCount The number of comments for this activity
	CommentCount *int `json:"comment_count,omitempty"`

	// Commute Whether this activity is a commute
	Commute *bool `json:"commute,omitempty"`

	// Description The description of the activity
	Description *string `json:"description,omitempty"`

	// DeviceName The name of the device used to record the activity
	DeviceName *string `json:"device_name,omitempty"`

	// Distance The activity's distance, in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The activity's elapsed time, in seconds
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// ElevHigh The activity's highest elevation, in meters
	ElevHigh *float32 `json:"elev_high,omitempty"`

	// ElevLow The activity's lowest elevation, in meters
	ElevLow *float32 `json:"elev_low,omitempty"`

	// EmbedToken The token used to embed a Strava activity
	EmbedToken *string `json:"embed_token,omitempty"`

	// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	EndLatlng *LatLng `json:"end_latlng,omitempty"`

	// ExternalId The identifier provided at upload time
	ExternalId *string `json:"external_id,omitempty"`

	// Flagged Whether this activity is flagged
	Flagged *bool        `json:"flagged,omitempty"`
	Gear    *SummaryGear `json:"gear,omitempty"`

	// Id The unique identifier of the activity
	Id *int64 `json:"id,omitempty"`

	// KudosCount The number of kudos given for this activity
	KudosCount *int   `json:"kudos_count,omitempty"`
	Laps       *[]Lap `json:"laps,omitempty"`

	// Manual Whether this activity was created manually
	Manual *bool        `json:"manual,omitempty"`
	Map    *PolylineMap `json:"map,omitempty"`

	// MaxSpeed The activity's max speed, in meters per second
	MaxSpeed *float32 `json:"max_speed,omitempty"`

	// MovingTime The activity's moving time, in seconds
	MovingTime *int `json:"moving_time,omitempty"`

	// Name The name of the activity
	Name *string `json:"name,omitempty"`

	// PhotoCount The number of Instagram photos for this activity
	PhotoCount *int `json:"photo_count,omitempty"`
	Photos     *struct {
		// Count The number of photos
		Count   *int `json:"count,omitempty"`
		Primary *struct {
			Id       *int64             `json:"id,omitempty"`
			Source   *int               `json:"source,omitempty"`
			UniqueId *string            `json:"unique_id,omitempty"`
			Urls     *map[string]string `json:"urls,omitempty"`
		} `json:"primary,omitempty"`
	} `json:"photos,omitempty"`

	// Private Whether this activity is private
	Private        *bool                    `json:"private,omitempty"`
	SegmentEfforts *[]DetailedSegmentEffort `json:"segment_efforts,omitempty"`

	// SplitsMetric The splits of this activity in metric units (for runs)
	SplitsMetric *[]Split `json:"splits_metric,omitempty"`

	// SplitsStandard The splits of this activity in imperial units (for runs)
	SplitsStandard *[]Split `json:"splits_standard,omitempty"`

	// SportType An enumeration of the types an activity may have.
	SportType *ActivityType `json:"sport_type,omitempty"`

	// StartDate The time at which the activity was started.
	StartDate *time.Time `json:"start_date,omitempty"`

	// StartDateLocal The time at which the activity was started in the local timezone.
	StartDateLocal *time.Time `json:"start_date_local,omitempty"`

	// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	StartLatlng *LatLng `json:"start_latlng,omitempty"`

	// Timezone The timezone of the activity
	Timezone *string `json:"timezone,omitempty"`

	// TotalElevationGain The activity's total elevation gain.
	TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

	// Trainer Whether this activity was recorded on a training machine
	Trainer *bool `json:"trainer,omitempty"`

	// Type An enumeration of the types an activity may have.
	Type *ActivityType `json:"type,omitempty"`

	// UploadId The identifier of the upload that resulted in this activity
	UploadId *int64 `json:"upload_id,omitempty"`

	// UploadIdStr The unique identifier of the upload in string format
	UploadIdStr *string `json:"upload_id_str,omitempty"`

	// WorkoutType The activity's workout type
	WorkoutType *int `json:"workout_type,omitempty"`
}

// DetailedAthlete defines model for DetailedAthlete.
type DetailedAthlete struct {
	// Bikes The athlete's bikes.
	Bikes *[]SummaryGear `json:"bikes,omitempty"`

	// City The athlete's city.
	City *string `json:"city,omitempty"`

	// Clubs The athlete's clubs.
	Clubs *[]SummaryClub `json:"clubs,omitempty"`

	// Country The athlete's country.
	Country *string `json:"country,omitempty"`

	// CreatedAt The time at which the athlete was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Firstname The athlete's first name.
	Firstname *string `json:"firstname,omitempty"`

	// FollowerCount The athlete's follower count.
	FollowerCount *int `json:"follower_count,omitempty"`

	// FriendCount The athlete's friend count.
	FriendCount *int `json:"friend_count,omitempty"`

	// Ftp The athlete's FTP (Functional Threshold Power).
	Ftp *int `json:"ftp,omitempty"`

	// Id The unique identifier of the athlete
	Id *int64 `json:"id,omitempty"`

	// Lastname The athlete's last name.
	Lastname *string `json:"lastname,omitempty"`

	// MeasurementPreference The athlete's preferred unit system.
	MeasurementPreference *DetailedAthleteMeasurementPreference `json:"measurement_preference,omitempty"`

	// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
	Premium *bool `json:"premium,omitempty"`

	// Profile URL to a 124x124 pixel profile picture.
	Profile *string `json:"profile,omitempty"`

	// ProfileMedium URL to a 62x62 pixel profile picture.
	ProfileMedium *string `json:"profile_medium,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`

	// Sex The athlete's sex.
	Sex *DetailedAthleteSex `json:"sex,omitempty"`

	// Shoes The athlete's shoes.
	Shoes *[]SummaryGear `json:"shoes,omitempty"`

	// State The athlete's state or geographical region.
	State *string `json:"state,omitempty"`

	// Summit Whether the athlete has any Summit subscription.
	Summit *bool `json:"summit,omitempty"`

	// UpdatedAt The time at which the athlete was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Weight The athlete's weight.
	Weight *float32 `json:"weight,omitempty"`
}

// DetailedAthleteMeasurementPreference The athlete's preferred unit system.
type DetailedAthleteMeasurementPreference string

// DetailedAthleteSex The athlete's sex.
type DetailedAthleteSex string

// DetailedClub defines model for DetailedClub.
type DetailedClub struct {
	// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
	ActivityTypes *[]ActivityType `json:"activity_types,omitempty"`

	// Admin Whether the currently logged-in athlete is an administrator of this club.
	Admin *bool `json:"admin,omitempty"`

	// City The club's city.
	City *string `json:"city,omitempty"`

	// Country The club's country.
	Country *string `json:"country,omitempty"`

	// CoverPhoto URL to a ~1185x580 pixel cover photo.
	CoverPhoto *string `json:"cover_photo,omitempty"`

	// CoverPhotoSmall URL to a ~360x176 pixel cover photo.
	CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

	// Featured Whether the club is featured or not.
	Featured *bool `json:"featured,omitempty"`

	// FollowingCount The number of athletes in the club that the logged-in athlete follows.
	FollowingCount *int `json:"following_count,omitempty"`

	// Id The club's unique identifier.
	Id *int64 `json:"id,omitempty"`

	// MemberCount The club's member count.
	MemberCount *int `json:"member_count,omitempty"`

	// Membership The membership status of the logged-in athlete.
	Membership *DetailedClubMembership `json:"membership,omitempty"`

	// Name The club's name.
	Name *string `json:"name,omitempty"`

	// Owner Whether the currently logged-in athlete is the owner of this club.
	Owner *bool `json:"owner,omitempty"`

	// Private Whether the club is private.
	Private *bool `json:"private,omitempty"`

	// ProfileMedium URL to a 60x60 pixel profile picture.
	ProfileMedium *string `json:"profile_medium,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`

	// SportType Deprecated. Prefer to use activity_types.
	SportType *DetailedClubSportType `json:"sport_type,omitempty"`

	// State The club's state or geographical region.
	State *string `json:"state,omitempty"`

	// Url The club's vanity URL.
	Url *string `json:"url,omitempty"`

	// Verified Whether the club is verified or not.
	Verified *bool `json:"verified,omitempty"`
}

// DetailedClubMembership The membership status of the logged-in athlete.
type DetailedClubMembership string

// DetailedClubSportType Deprecated. Prefer to use activity_types.
type DetailedClubSportType string

// DetailedGear defines model for DetailedGear.
type DetailedGear struct {
	// BrandName The gear's brand name.
	BrandName *string `json:"brand_name,omitempty"`

	// Description The gear's description.
	Description *string `json:"description,omitempty"`

	// Distance The distance logged with this gear.
	Distance *float32 `json:"distance,omitempty"`

	// FrameType The gear's frame type (bike only).
	FrameType *int `json:"frame_type,omitempty"`

	// Id The gear's unique identifier.
	Id *string `json:"id,omitempty"`

	// ModelName The gear's model name.
	ModelName *string `json:"model_name,omitempty"`

	// Name The gear's name.
	Name *string `json:"name,omitempty"`

	// Primary Whether this gear's is the owner's default one.
	Primary *bool `json:"primary,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`
}

// DetailedSegment defines model for DetailedSegment.
type DetailedSegment struct {
	ActivityType *DetailedSegmentActivityType `json:"activity_type,omitempty"`

	// AthleteCount The number of unique athletes who have an effort for this segment
	AthleteCount    *int `json:"athlete_count,omitempty"`
	AthletePrEffort *struct {
		// EffortCount Number of efforts by the authenticated athlete on this segment.
		EffortCount *int `json:"effort_count,omitempty"`

		// PrActivityId The unique identifier of the activity related to the PR effort.
		PrActivityId *int64 `json:"pr_activity_id,omitempty"`

		// PrDate The time at which the PR effort was started.
		PrDate *time.Time `json:"pr_date,omitempty"`

		// PrElapsedTime The elapsed time ot the PR effort.
		PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
	} `json:"athlete_pr_effort,omitempty"`
	AthleteSegmentStats *SummarySegmentEffort `json:"athlete_segment_stats,omitempty"`

	// AverageGrade The segment's average grade, in percents
	AverageGrade *float32 `json:"average_grade,omitempty"`

	// City The segments's city.
	City *string `json:"city,omitempty"`

	// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catÃ©gorie, 0 is uncategorized in climb_category.
	ClimbCategory *int `json:"climb_category,omitempty"`

	// Country The segment's country.
	Country *string `json:"country,omitempty"`

	// CreatedAt The time at which the segment was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Distance The segment's distance, in meters
	Distance *float32 `json:"distance,omitempty"`

	// EffortCount The total number of efforts for this segment
	EffortCount *int `json:"effort_count,omitempty"`

	// ElevationHigh The segments's highest elevation, in meters
	ElevationHigh *float32 `json:"elevation_high,omitempty"`

	// ElevationLow The segments's lowest elevation, in meters
	ElevationLow *float32 `json:"elevation_low,omitempty"`

	// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	EndLatlng *LatLng `json:"end_latlng,omitempty"`

	// Hazardous Whether this segment is considered hazardous
	Hazardous *bool `json:"hazardous,omitempty"`

	// Id The unique identifier of this segment
	Id  *int64       `json:"id,omitempty"`
	Map *PolylineMap `json:"map,omitempty"`

	// MaximumGrade The segments's maximum grade, in percents
	MaximumGrade *float32 `json:"maximum_grade,omitempty"`

	// Name The name of this segment
	Name *string `json:"name,omitempty"`

	// Private Whether this segment is private.
	Private *bool `json:"private,omitempty"`

	// StarCount The number of stars for this segment
	StarCount *int `json:"star_count,omitempty"`

	// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	StartLatlng *LatLng `json:"start_latlng,omitempty"`

	// State The segments's state or geographical region.
	State *string `json:"state,omitempty"`

	// TotalElevationGain The segment's total elevation gain.
	TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

	// UpdatedAt The time at which the segment was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// DetailedSegmentActivityType defines model for DetailedSegment.ActivityType.
type DetailedSegmentActivityType string

// DetailedSegmentEffort defines model for DetailedSegmentEffort.
type DetailedSegmentEffort struct {
	Activity *MetaActivity `json:"activity,omitempty"`

	// ActivityId The unique identifier of the activity related to this effort
	ActivityId *int64       `json:"activity_id,omitempty"`
	Athlete    *MetaAthlete `json:"athlete,omitempty"`

	// AverageCadence The effort's average cadence
	AverageCadence *float32 `json:"average_cadence,omitempty"`

	// AverageHeartrate The heart heart rate of the athlete during this effort
	AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

	// AverageWatts The average wattage of this effort
	AverageWatts *float32 `json:"average_watts,omitempty"`

	// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
	DeviceWatts *bool `json:"device_watts,omitempty"`

	// Distance The effort's distance in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The effort's elapsed time
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// EndIndex The end index of this effort in its activity's stream
	EndIndex *int `json:"end_index,omitempty"`

	// Hidden Whether this effort should be hidden when viewed within an activity
	Hidden *bool `json:"hidden,omitempty"`

	// Id The unique identifier of this effort
	Id *int64 `json:"id,omitempty"`

	// IsKom Whether this effort is the current best on the leaderboard
	IsKom *bool `json:"is_kom,omitempty"`

	// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
	KomRank *int `json:"kom_rank,omitempty"`

	// MaxHeartrate The maximum heart rate of the athlete during this effort
	MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

	// MovingTime The effort's moving time
	MovingTime *int `json:"moving_time,omitempty"`

	// Name The name of the segment on which this effort was performed
	Name *string `json:"name,omitempty"`

	// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
	PrRank  *int            `json:"pr_rank,omitempty"`
	Segment *SummarySegment `json:"segment,omitempty"`

	// StartDate The time at which the effort was started.
	StartDate *time.Time `json:"start_date,omitempty"`

	// StartDateLocal The time at which the effort was started in the local timezone.
	StartDateLocal *time.Time `json:"start_date_local,omitempty"`

	// StartIndex The start index of this effort in its activity's stream
	StartIndex *int `json:"start_index,omitempty"`
}

// Error Encapsulates the errors that may be returned from the API.
type Error struct {
	// Errors The set of specific errors associated with this fault, if any.
	Errors *[]struct {
		// Code The code associated with this error.
		Code *string `json:"code,omitempty"`

		// Field The specific field or aspect of the resource associated with this error.
		Field *string `json:"field,omitempty"`

		// Resource The type of resource associated with this error.
		Resource *string `json:"resource,omitempty"`
	} `json:"errors,omitempty"`

	// Message The message of the fault.
	Message *string `json:"message,omitempty"`
}

// Lap defines model for Lap.
type Lap struct {
	Activity *MetaActivity `json:"activity,omitempty"`
	Athlete  *MetaAthlete  `json:"athlete,omitempty"`

	// AverageCadence The lap's average cadence
	AverageCadence *float32 `json:"average_cadence,omitempty"`

	// AverageSpeed The lap's average speed
	AverageSpeed *float32 `json:"average_speed,omitempty"`

	// Distance The lap's distance, in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The lap's elapsed time, in seconds
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// EndIndex The end index of this effort in its activity's stream
	EndIndex *int `json:"end_index,omitempty"`

	// Id The unique identifier of this lap
	Id *int64 `json:"id,omitempty"`

	// LapIndex The index of this lap in the activity it belongs to
	LapIndex *int `json:"lap_index,omitempty"`

	// MaxSpeed The maximum speed of this lat, in meters per second
	MaxSpeed *float32 `json:"max_speed,omitempty"`

	// MovingTime The lap's moving time, in seconds
	MovingTime *int `json:"moving_time,omitempty"`

	// Name The name of the lap
	Name *string `json:"name,omitempty"`

	// PaceZone The pacing zone of this lap
	PaceZone *int `json:"pace_zone,omitempty"`

	// Split The split index of this lap
	Split *int `json:"split,omitempty"`

	// StartDate The time at which the lap was started.
	StartDate *time.Time `json:"start_date,omitempty"`

	// StartDateLocal The time at which the lap was started in the local timezone.
	StartDateLocal *time.Time `json:"start_date_local,omitempty"`

	// StartIndex The start index of this effort in its activity's stream
	StartIndex *int `json:"start_index,omitempty"`

	// TotalElevationGain The elevation gain of this lap, in meters
	TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`
}

// LatLng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
type LatLng = []float32

// MetaActivity defines model for MetaActivity.
type MetaActivity struct {
	// Id The unique identifier of the activity
	Id *int64 `json:"id,omitempty"`
}

// MetaAthlete defines model for MetaAthlete.
type MetaAthlete struct {
	// Id The unique identifier of the athlete
	Id *int64 `json:"id,omitempty"`
}

// MetaClub defines model for MetaClub.
type MetaClub struct {
	// Id The club's unique identifier.
	Id *int64 `json:"id,omitempty"`

	// Name The club's name.
	Name *string `json:"name,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`
}

// PolylineMap defines model for PolylineMap.
type PolylineMap struct {
	// Id The identifier of the map
	Id *string `json:"id,omitempty"`

	// Polyline The polyline of the map, only returned in certain requests
	Polyline *string `json:"polyline,omitempty"`

	// SummaryPolyline The summary polyline of the map
	SummaryPolyline *string `json:"summary_polyline,omitempty"`
}

// Route defines model for Route.
type Route struct {
	Athlete *SummaryAthlete `json:"athlete,omitempty"`

	// Description The description of the route
	Description *string `json:"description,omitempty"`

	// Distance The route's distance, in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElevationGain The route's elevation gain.
	ElevationGain *float32 `json:"elevation_gain,omitempty"`

	// Id The unique identifier of this route
	Id *int64 `json:"id,omitempty"`

	// IdStr The unique identifier of the route in string format
	IdStr *string      `json:"id_str,omitempty"`
	Map   *PolylineMap `json:"map,omitempty"`

	// Name The name of the route
	Name *string `json:"name,omitempty"`

	// Private Whether this route is private
	Private  *bool             `json:"private,omitempty"`
	Segments *[]SummarySegment `json:"segments,omitempty"`

	// Starred Whether this route is starred by the logged-in athlete
	Starred *bool `json:"starred,omitempty"`

	// SubType This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
	SubType *int `json:"sub_type,omitempty"`

	// Timestamp An epoch timestamp of when the route was created
	Timestamp *int `json:"timestamp,omitempty"`

	// Type This route's type (1 for ride, 2 for runs)
	Type      *int        `json:"type,omitempty"`
	Waypoints *[]Waypoint `json:"waypoints,omitempty"`
}

// Split defines model for Split.
type Split struct {
	// AverageSpeed The average speed of this split, in meters per second
	AverageSpeed *float32 `json:"average_speed,omitempty"`

	// Distance The distance of this split, in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The elapsed time of this split, in seconds
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// ElevationDifference The elevation difference of this split, in meters
	ElevationDifference *float32 `json:"elevation_difference,omitempty"`

	// MovingTime The moving time of this split, in seconds
	MovingTime *int `json:"moving_time,omitempty"`

	// PaceZone The pacing zone of this split
	PaceZone *int `json:"pace_zone,omitempty"`

	// Split N/A
	Split *int `json:"split,omitempty"`
}

// StreamSet defines model for StreamSet.
type StreamSet struct {
	Altitude *struct {
		Data *[]float32 `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetAltitudeResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetAltitudeSeriesType `json:"series_type,omitempty"`
	} `json:"altitude,omitempty"`
	Cadence *struct {
		Data *[]int `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetCadenceResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetCadenceSeriesType `json:"series_type,omitempty"`
	} `json:"cadence,omitempty"`
	Distance *struct {
		Data *[]float32 `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetDistanceResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetDistanceSeriesType `json:"series_type,omitempty"`
	} `json:"distance,omitempty"`
	GradeSmooth *struct {
		Data *[]float32 `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetGradeSmoothResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetGradeSmoothSeriesType `json:"series_type,omitempty"`
	} `json:"grade_smooth,omitempty"`
	Heartrate *struct {
		Data *[]int `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetHeartrateResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetHeartrateSeriesType `json:"series_type,omitempty"`
	} `json:"heartrate,omitempty"`
	Latlng *struct {
		Data *[]LatLng `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetLatlngResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetLatlngSeriesType `json:"series_type,omitempty"`
	} `json:"latlng,omitempty"`
	Moving *struct {
		Data *[]bool `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetMovingResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetMovingSeriesType `json:"series_type,omitempty"`
	} `json:"moving,omitempty"`
	Temp *struct {
		Data *[]int `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetTempResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetTempSeriesType `json:"series_type,omitempty"`
	} `json:"temp,omitempty"`
	Time *struct {
		Data *[]int `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetTimeResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetTimeSeriesType `json:"series_type,omitempty"`
	} `json:"time,omitempty"`
	VelocitySmooth *struct {
		Data *[]float32 `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetVelocitySmoothResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetVelocitySmoothSeriesType `json:"series_type,omitempty"`
	} `json:"velocity_smooth,omitempty"`
	Watts *struct {
		Data *[]int `json:"data,omitempty"`

		// OriginalSize The number of data points in this stream
		OriginalSize *int `json:"original_size,omitempty"`

		// Resolution The level of detail (sampling) in which this stream was returned
		Resolution *StreamSetWattsResolution `json:"resolution,omitempty"`

		// SeriesType The base series used in the case the stream was downsampled
		SeriesType *StreamSetWattsSeriesType `json:"series_type,omitempty"`
	} `json:"watts,omitempty"`
}

// StreamSetAltitudeResolution The level of detail (sampling) in which this stream was returned
type StreamSetAltitudeResolution string

// StreamSetAltitudeSeriesType The base series used in the case the stream was downsampled
type StreamSetAltitudeSeriesType string

// StreamSetCadenceResolution The level of detail (sampling) in which this stream was returned
type StreamSetCadenceResolution string

// StreamSetCadenceSeriesType The base series used in the case the stream was downsampled
type StreamSetCadenceSeriesType string

// StreamSetDistanceResolution The level of detail (sampling) in which this stream was returned
type StreamSetDistanceResolution string

// StreamSetDistanceSeriesType The base series used in the case the stream was downsampled
type StreamSetDistanceSeriesType string

// StreamSetGradeSmoothResolution The level of detail (sampling) in which this stream was returned
type StreamSetGradeSmoothResolution string

// StreamSetGradeSmoothSeriesType The base series used in the case the stream was downsampled
type StreamSetGradeSmoothSeriesType string

// StreamSetHeartrateResolution The level of detail (sampling) in which this stream was returned
type StreamSetHeartrateResolution string

// StreamSetHeartrateSeriesType The base series used in the case the stream was downsampled
type StreamSetHeartrateSeriesType string

// StreamSetLatlngResolution The level of detail (sampling) in which this stream was returned
type StreamSetLatlngResolution string

// StreamSetLatlngSeriesType The base series used in the case the stream was downsampled
type StreamSetLatlngSeriesType string

// StreamSetMovingResolution The level of detail (sampling) in which this stream was returned
type StreamSetMovingResolution string

// StreamSetMovingSeriesType The base series used in the case the stream was downsampled
type StreamSetMovingSeriesType string

// StreamSetTempResolution The level of detail (sampling) in which this stream was returned
type StreamSetTempResolution string

// StreamSetTempSeriesType The base series used in the case the stream was downsampled
type StreamSetTempSeriesType string

// StreamSetTimeResolution The level of detail (sampling) in which this stream was returned
type StreamSetTimeResolution string

// StreamSetTimeSeriesType The base series used in the case the stream was downsampled
type StreamSetTimeSeriesType string

// StreamSetVelocitySmoothResolution The level of detail (sampling) in which this stream was returned
type StreamSetVelocitySmoothResolution string

// StreamSetVelocitySmoothSeriesType The base series used in the case the stream was downsampled
type StreamSetVelocitySmoothSeriesType string

// StreamSetWattsResolution The level of detail (sampling) in which this stream was returned
type StreamSetWattsResolution string

// StreamSetWattsSeriesType The base series used in the case the stream was downsampled
type StreamSetWattsSeriesType string

// SummaryActivity defines model for SummaryActivity.
type SummaryActivity struct {
	// AchievementCount The number of achievements gained during this activity
	AchievementCount *int         `json:"achievement_count,omitempty"`
	Athlete          *MetaAthlete `json:"athlete,omitempty"`

	// AthleteCount The number of athletes for taking part in a group activity
	AthleteCount *int `json:"athlete_count,omitempty"`

	// AverageSpeed The activity's average speed, in meters per second
	AverageSpeed *float32 `json:"average_speed,omitempty"`

	// CommentCount The number of comments for this activity
	CommentCount *int `json:"comment_count,omitempty"`

	// Commute Whether this activity is a commute
	Commute *bool `json:"commute,omitempty"`

	// Distance The activity's distance, in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The activity's elapsed time, in seconds
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// ElevHigh The activity's highest elevation, in meters
	ElevHigh *float32 `json:"elev_high,omitempty"`

	// ElevLow The activity's lowest elevation, in meters
	ElevLow *float32 `json:"elev_low,omitempty"`

	// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	EndLatlng *LatLng `json:"end_latlng,omitempty"`

	// ExternalId The identifier provided at upload time
	ExternalId *string `json:"external_id,omitempty"`

	// Flagged Whether this activity is flagged
	Flagged *bool `json:"flagged,omitempty"`

	// Id The unique identifier of the activity
	Id *int64 `json:"id,omitempty"`

	// KudosCount The number of kudos given for this activity
	KudosCount *int `json:"kudos_count,omitempty"`

	// Manual Whether this activity was created manually
	Manual *bool        `json:"manual,omitempty"`
	Map    *PolylineMap `json:"map,omitempty"`

	// MaxSpeed The activity's max speed, in meters per second
	MaxSpeed *float32 `json:"max_speed,omitempty"`

	// MovingTime The activity's moving time, in seconds
	MovingTime *int `json:"moving_time,omitempty"`

	// Name The name of the activity
	Name *string `json:"name,omitempty"`

	// PhotoCount The number of Instagram photos for this activity
	PhotoCount *int `json:"photo_count,omitempty"`

	// Private Whether this activity is private
	Private *bool `json:"private,omitempty"`

	// SportType An enumeration of the types an activity may have.
	SportType *ActivityType `json:"sport_type,omitempty"`

	// StartDate The time at which the activity was started.
	StartDate *time.Time `json:"start_date,omitempty"`

	// StartDateLocal The time at which the activity was started in the local timezone.
	StartDateLocal *time.Time `json:"start_date_local,omitempty"`

	// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	StartLatlng *LatLng `json:"start_latlng,omitempty"`

	// Timezone The timezone of the activity
	Timezone *string `json:"timezone,omitempty"`

	// TotalElevationGain The activity's total elevation gain.
	TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

	// Trainer Whether this activity was recorded on a training machine
	Trainer *bool `json:"trainer,omitempty"`

	// Type An enumeration of the types an activity may have.
	Type *ActivityType `json:"type,omitempty"`

	// UploadId The identifier of the upload that resulted in this activity
	UploadId *int64 `json:"upload_id,omitempty"`

	// UploadIdStr The unique identifier of the upload in string format
	UploadIdStr *string `json:"upload_id_str,omitempty"`

	// WorkoutType The activity's workout type
	WorkoutType *int `json:"workout_type,omitempty"`
}

// SummaryAthlete defines model for SummaryAthlete.
type SummaryAthlete struct {
	// City The athlete's city.
	City *string `json:"city,omitempty"`

	// Country The athlete's country.
	Country *string `json:"country,omitempty"`

	// CreatedAt The time at which the athlete was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Firstname The athlete's first name.
	Firstname *string `json:"firstname,omitempty"`

	// Id The unique identifier of the athlete
	Id *int64 `json:"id,omitempty"`

	// Lastname The athlete's last name.
	Lastname *string `json:"lastname,omitempty"`

	// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
	Premium *bool `json:"premium,omitempty"`

	// Profile URL to a 124x124 pixel profile picture.
	Profile *string `json:"profile,omitempty"`

	// ProfileMedium URL to a 62x62 pixel profile picture.
	ProfileMedium *string `json:"profile_medium,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`

	// Sex The athlete's sex.
	Sex *SummaryAthleteSex `json:"sex,omitempty"`

	// State The athlete's state or geographical region.
	State *string `json:"state,omitempty"`

	// Summit Whether the athlete has any Summit subscription.
	Summit *bool `json:"summit,omitempty"`

	// UpdatedAt The time at which the athlete was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// SummaryAthleteSex The athlete's sex.
type SummaryAthleteSex string

// SummaryClub defines model for SummaryClub.
type SummaryClub struct {
	// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
	ActivityTypes *[]ActivityType `json:"activity_types,omitempty"`

	// City The club's city.
	City *string `json:"city,omitempty"`

	// Country The club's country.
	Country *string `json:"country,omitempty"`

	// CoverPhoto URL to a ~1185x580 pixel cover photo.
	CoverPhoto *string `json:"cover_photo,omitempty"`

	// CoverPhotoSmall URL to a ~360x176 pixel cover photo.
	CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

	// Featured Whether the club is featured or not.
	Featured *bool `json:"featured,omitempty"`

	// Id The club's unique identifier.
	Id *int64 `json:"id,omitempty"`

	// MemberCount The club's member count.
	MemberCount *int `json:"member_count,omitempty"`

	// Name The club's name.
	Name *string `json:"name,omitempty"`

	// Private Whether the club is private.
	Private *bool `json:"private,omitempty"`

	// ProfileMedium URL to a 60x60 pixel profile picture.
	ProfileMedium *string `json:"profile_medium,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`

	// SportType Deprecated. Prefer to use activity_types.
	SportType *SummaryClubSportType `json:"sport_type,omitempty"`

	// State The club's state or geographical region.
	State *string `json:"state,omitempty"`

	// Url The club's vanity URL.
	Url *string `json:"url,omitempty"`

	// Verified Whether the club is verified or not.
	Verified *bool `json:"verified,omitempty"`
}

// SummaryClubSportType Deprecated. Prefer to use activity_types.
type SummaryClubSportType string

// SummaryGear defines model for SummaryGear.
type SummaryGear struct {
	// Distance The distance logged with this gear.
	Distance *float32 `json:"distance,omitempty"`

	// Id The gear's unique identifier.
	Id *string `json:"id,omitempty"`

	// Name The gear's name.
	Name *string `json:"name,omitempty"`

	// Primary Whether this gear's is the owner's default one.
	Primary *bool `json:"primary,omitempty"`

	// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
	ResourceState *int `json:"resource_state,omitempty"`
}

// SummarySegment defines model for SummarySegment.
type SummarySegment struct {
	ActivityType    *SummarySegmentActivityType `json:"activity_type,omitempty"`
	AthletePrEffort *struct {
		// EffortCount Number of efforts by the authenticated athlete on this segment.
		EffortCount *int `json:"effort_count,omitempty"`

		// PrActivityId The unique identifier of the activity related to the PR effort.
		PrActivityId *int64 `json:"pr_activity_id,omitempty"`

		// PrDate The time at which the PR effort was started.
		PrDate *time.Time `json:"pr_date,omitempty"`

		// PrElapsedTime The elapsed time ot the PR effort.
		PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
	} `json:"athlete_pr_effort,omitempty"`
	AthleteSegmentStats *SummarySegmentEffort `json:"athlete_segment_stats,omitempty"`

	// AverageGrade The segment's average grade, in percents
	AverageGrade *float32 `json:"average_grade,omitempty"`

	// City The segments's city.
	City *string `json:"city,omitempty"`

	// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catÃ©gorie, 0 is uncategorized in climb_category.
	ClimbCategory *int `json:"climb_category,omitempty"`

	// Country The segment's country.
	Country *string `json:"country,omitempty"`

	// Distance The segment's distance, in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElevationHigh The segments's highest elevation, in meters
	ElevationHigh *float32 `json:"elevation_high,omitempty"`

	// ElevationLow The segments's lowest elevation, in meters
	ElevationLow *float32 `json:"elevation_low,omitempty"`

	// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	EndLatlng *LatLng `json:"end_latlng,omitempty"`

	// Id The unique identifier of this segment
	Id *int64 `json:"id,omitempty"`

	// MaximumGrade The segments's maximum grade, in percents
	MaximumGrade *float32 `json:"maximum_grade,omitempty"`

	// Name The name of this segment
	Name *string `json:"name,omitempty"`

	// Private Whether this segment is private.
	Private *bool `json:"private,omitempty"`

	// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	StartLatlng *LatLng `json:"start_latlng,omitempty"`

	// State The segments's state or geographical region.
	State *string `json:"state,omitempty"`
}

// SummarySegmentActivityType defines model for SummarySegment.ActivityType.
type SummarySegmentActivityType string

// SummarySegmentEffort defines model for SummarySegmentEffort.
type SummarySegmentEffort struct {
	// ActivityId The unique identifier of the activity related to this effort
	ActivityId *int64 `json:"activity_id,omitempty"`

	// Distance The effort's distance in meters
	Distance *float32 `json:"distance,omitempty"`

	// ElapsedTime The effort's elapsed time
	ElapsedTime *int `json:"elapsed_time,omitempty"`

	// Id The unique identifier of this effort
	Id *int64 `json:"id,omitempty"`

	// IsKom Whether this effort is the current best on the leaderboard
	IsKom *bool `json:"is_kom,omitempty"`

	// StartDate The time at which the effort was started.
	StartDate *time.Time `json:"start_date,omitempty"`

	// StartDateLocal The time at which the effort was started in the local timezone.
	StartDateLocal *time.Time `json:"start_date_local,omitempty"`
}

// Upload defines model for Upload.
type Upload struct {
	// ActivityId The identifier of the activity this upload resulted into
	ActivityId *int64 `json:"activity_id,omitempty"`

	// Error The error associated with this upload
	Error *string `json:"error,omitempty"`

	// ExternalId The external identifier of the upload
	ExternalId *string `json:"external_id,omitempty"`

	// Id The unique identifier of the upload
	Id *int64 `json:"id,omitempty"`

	// IdStr The unique identifier of the upload in string format
	IdStr *string `json:"id_str,omitempty"`

	// Status The status of this upload
	Status *string `json:"status,omitempty"`
}

// Waypoint defines model for Waypoint.
type Waypoint struct {
	// Categories Categories for the waypoint
	Categories *[]string `json:"categories,omitempty"`

	// Description The description of the waypoint
	Description *string `json:"description,omitempty"`

	// DistanceIntoRoute The distance into the route the waypoint is at
	DistanceIntoRoute *int `json:"distance_into_route,omitempty"`

	// Latlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	Latlng *LatLng `json:"latlng,omitempty"`

	// TargetLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
	TargetLatlng *LatLng `json:"target_latlng,omitempty"`

	// Title The title of the waypoint
	Title *string `json:"title,omitempty"`
}

// ZoneRange defines model for ZoneRange.
type ZoneRange struct {
	// Max The maximum value in the range.
	Max *int `json:"max,omitempty"`

	// Min The minimum value in the range.
	Min *int `json:"min,omitempty"`
}

// Zones defines model for Zones.
type Zones struct {
	HeartRate *struct {
		// CustomZones Whether the athlete has set their own custom heart rate zones
		CustomZones *bool        `json:"custom_zones,omitempty"`
		Zones       *[]ZoneRange `json:"zones,omitempty"`
	} `json:"heart_rate,omitempty"`
	Power *struct {
		Zones *[]ZoneRange `json:"zones,omitempty"`
	} `json:"power,omitempty"`
}

// Page defines model for page.
type Page = int

// PerPage defines model for perPage.
type PerPage = int

// CreateActivityFormdataBody defines parameters for CreateActivity.
type CreateActivityFormdataBody struct {
	// Commute Set to 1 to mark as commute.
	Commute *int `form:"commute,omitempty" json:"commute,omitempty"`

	// Description Description of the activity.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Distance In meters.
	Distance *float32 `form:"distance,omitempty" json:"distance,omitempty"`

	// ElapsedTime In seconds.
	ElapsedTime int `form:"elapsed_time" json:"elapsed_time"`

	// Name The name of the activity.
	Name string `form:"name" json:"name"`

	// SportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
	SportType string `form:"sport_type" json:"sport_type"`

	// StartDateLocal ISO 8601 formatted date time.
	StartDateLocal time.Time `form:"start_date_local" json:"start_date_local"`

	// Trainer Set to 1 to mark as a trainer activity.
	Trainer *int `form:"trainer,omitempty" json:"trainer,omitempty"`

	// Type Type of activity. For example - Run, Ride etc.
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// GetActivityByIdParams defines parameters for GetActivityById.
type GetActivityByIdParams struct {
	// IncludeAllEfforts To include all segments efforts.
	IncludeAllEfforts *bool `form:"include_all_efforts,omitempty" json:"include_all_efforts,omitempty"`
}

// UpdateActivityByIdJSONBody defines parameters for UpdateActivityById.
type UpdateActivityByIdJSONBody struct {
	// Commute Whether this activity is a commute
	Commute *bool `json:"commute,omitempty"`

	// Description The description of the activity
	Description *string `json:"description,omitempty"`

	// GearId Identifier for the gear associated with the activity. ânoneâ clears gear from activity
	GearId *string `json:"gear_id,omitempty"`

	// HideFromHome Whether this activity is muted
	HideFromHome *bool `json:"hide_from_home,omitempty"`

	// Name The name of the activity
	Name *string `json:"name,omitempty"`

	// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
	SportType *UpdateActivityByIdJSONBodySportType `json:"sport_type,omitempty"`

	// Trainer Whether this activity was recorded on a training machine
	Trainer *bool `json:"trainer,omitempty"`

	// Type An enumeration of the types an activity may have.
	Type *ActivityType `json:"type,omitempty"`
}

// UpdateActivityByIdJSONBodySportType defines parameters for UpdateActivityById.
type UpdateActivityByIdJSONBodySportType string

// GetCommentsByActivityIdParams defines parameters for GetCommentsByActivityId.
type GetCommentsByActivityIdParams struct {
	// Page Deprecated. Prefer to use after_cursor.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Deprecated. Prefer to use page_size.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// PageSize Number of items per page. Defaults to 30.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// AfterCursor Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
	AfterCursor *string `form:"after_cursor,omitempty" json:"after_cursor,omitempty"`
}

// GetKudoersByActivityIdParams defines parameters for GetKudoersByActivityId.
type GetKudoersByActivityIdParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetActivityStreamsParams defines parameters for GetActivityStreams.
type GetActivityStreamsParams struct {
	// Keys Desired stream types.
	Keys []GetActivityStreamsParamsKeys `form:"keys" json:"keys"`

	// KeyByType Must be true.
	KeyByType bool `form:"key_by_type" json:"key_by_type"`
}

// GetActivityStreamsParamsKeys defines parameters for GetActivityStreams.
type GetActivityStreamsParamsKeys string

// UpdateLoggedInAthleteParams defines parameters for UpdateLoggedInAthlete.
type UpdateLoggedInAthleteParams struct {
	// Weight The weight of the athlete in kilograms.
	Weight float32 `form:"weight" json:"weight"`
}

// GetLoggedInAthleteActivitiesParams defines parameters for GetLoggedInAthleteActivities.
type GetLoggedInAthleteActivitiesParams struct {
	// Before An epoch timestamp to use for filtering activities that have taken place before a certain time.
	Before *int `form:"before,omitempty" json:"before,omitempty"`

	// After An epoch timestamp to use for filtering activities that have taken place after a certain time.
	After *int `form:"after,omitempty" json:"after,omitempty"`

	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetLoggedInAthleteClubsParams defines parameters for GetLoggedInAthleteClubs.
type GetLoggedInAthleteClubsParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetRoutesByAthleteIdParams defines parameters for GetRoutesByAthleteId.
type GetRoutesByAthleteIdParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetClubActivitiesByIdParams defines parameters for GetClubActivitiesById.
type GetClubActivitiesByIdParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetClubAdminsByIdParams defines parameters for GetClubAdminsById.
type GetClubAdminsByIdParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetClubMembersByIdParams defines parameters for GetClubMembersById.
type GetClubMembersByIdParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetEffortsBySegmentIdParams defines parameters for GetEffortsBySegmentId.
type GetEffortsBySegmentIdParams struct {
	// SegmentId The identifier of the segment.
	SegmentId int `form:"segment_id" json:"segment_id"`

	// StartDateLocal ISO 8601 formatted date time.
	StartDateLocal *time.Time `form:"start_date_local,omitempty" json:"start_date_local,omitempty"`

	// EndDateLocal ISO 8601 formatted date time.
	EndDateLocal *time.Time `form:"end_date_local,omitempty" json:"end_date_local,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSegmentEffortStreamsParams defines parameters for GetSegmentEffortStreams.
type GetSegmentEffortStreamsParams struct {
	// Keys The types of streams to return.
	Keys []GetSegmentEffortStreamsParamsKeys `form:"keys" json:"keys"`

	// KeyByType Must be true.
	KeyByType bool `form:"key_by_type" json:"key_by_type"`
}

// GetSegmentEffortStreamsParamsKeys defines parameters for GetSegmentEffortStreams.
type GetSegmentEffortStreamsParamsKeys string

// ExploreSegmentsParams defines parameters for ExploreSegments.
type ExploreSegmentsParams struct {
	// Bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
	Bounds []float32 `form:"bounds" json:"bounds"`

	// ActivityType Desired activity type.
	ActivityType *ExploreSegmentsParamsActivityType `form:"activity_type,omitempty" json:"activity_type,omitempty"`

	// MinCat The minimum climbing category.
	MinCat *int `form:"min_cat,omitempty" json:"min_cat,omitempty"`

	// MaxCat The maximum climbing category.
	MaxCat *int `form:"max_cat,omitempty" json:"max_cat,omitempty"`
}

// ExploreSegmentsParamsActivityType defines parameters for ExploreSegments.
type ExploreSegmentsParamsActivityType string

// GetLoggedInAthleteStarredSegmentsParams defines parameters for GetLoggedInAthleteStarredSegments.
type GetLoggedInAthleteStarredSegmentsParams struct {
	// Page Page number. Defaults to 1.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// StarSegmentFormdataBody defines parameters for StarSegment.
type StarSegmentFormdataBody struct {
	// Starred If true, star the segment; if false, unstar the segment.
	Starred bool `form:"starred" json:"starred"`
}

// GetSegmentStreamsParams defines parameters for GetSegmentStreams.
type GetSegmentStreamsParams struct {
	// Keys The types of streams to return.
	Keys []GetSegmentStreamsParamsKeys `form:"keys" json:"keys"`

	// KeyByType Must be true.
	KeyByType bool `form:"key_by_type" json:"key_by_type"`
}

// GetSegmentStreamsParamsKeys defines parameters for GetSegmentStreams.
type GetSegmentStreamsParamsKeys string

// CreateUploadMultipartBody defines parameters for CreateUpload.
type CreateUploadMultipartBody struct {
	// Commute Whether the resulting activity should be tagged as a commute.
	Commute *string `json:"commute,omitempty"`

	// DataType The format of the uploaded file.
	DataType *CreateUploadMultipartBodyDataType `json:"data_type,omitempty"`

	// Description The desired description of the resulting activity.
	Description *string `json:"description,omitempty"`

	// ExternalId The desired external identifier of the resulting activity.
	ExternalId *string `json:"external_id,omitempty"`

	// File The uploaded file.
	File *openapi_types.File `json:"file,omitempty"`

	// Name The desired name of the resulting activity.
	Name *string `json:"name,omitempty"`

	// Trainer Whether the resulting activity should be marked as having been performed on a trainer.
	Trainer *string `json:"trainer,omitempty"`
}

// CreateUploadMultipartBodyDataType defines parameters for CreateUpload.
type CreateUploadMultipartBodyDataType string

// CreateActivityFormdataRequestBody defines body for CreateActivity for application/x-www-form-urlencoded ContentType.
type CreateActivityFormdataRequestBody CreateActivityFormdataBody

// UpdateActivityByIdJSONRequestBody defines body for UpdateActivityById for application/json ContentType.
type UpdateActivityByIdJSONRequestBody UpdateActivityByIdJSONBody

// StarSegmentFormdataRequestBody defines body for StarSegment for application/x-www-form-urlencoded ContentType.
type StarSegmentFormdataRequestBody StarSegmentFormdataBody

// CreateUploadMultipartRequestBody defines body for CreateUpload for multipart/form-data ContentType.
type CreateUploadMultipartRequestBody CreateUploadMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateActivityWithBody request with any body
	CreateActivityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateActivityWithFormdataBody(ctx context.Context, body CreateActivityFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityById request
	GetActivityById(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateActivityByIdWithBody request with any body
	UpdateActivityByIdWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateActivityById(ctx context.Context, id int64, body UpdateActivityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommentsByActivityId request
	GetCommentsByActivityId(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKudoersByActivityId request
	GetKudoersByActivityId(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLapsByActivityId request
	GetLapsByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityStreams request
	GetActivityStreams(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZonesByActivityId request
	GetZonesByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthlete request
	GetLoggedInAthlete(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoggedInAthlete request
	UpdateLoggedInAthlete(ctx context.Context, params *UpdateLoggedInAthleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteActivities request
	GetLoggedInAthleteActivities(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteClubs request
	GetLoggedInAthleteClubs(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteZones request
	GetLoggedInAthleteZones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesByAthleteId request
	GetRoutesByAthleteId(ctx context.Context, id int, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubById request
	GetClubById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubActivitiesById request
	GetClubActivitiesById(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubAdminsById request
	GetClubAdminsById(ctx context.Context, id int64, params *GetClubAdminsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubMembersById request
	GetClubMembersById(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGearById request
	GetGearById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRouteById request
	GetRouteById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRouteAsGPX request
	GetRouteAsGPX(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRouteAsTCX request
	GetRouteAsTCX(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRouteStreams request
	GetRouteStreams(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEffortsBySegmentId request
	GetEffortsBySegmentId(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSegmentEffortById request
	GetSegmentEffortById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSegmentEffortStreams request
	GetSegmentEffortStreams(ctx context.Context, id int64, params *GetSegmentEffortStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExploreSegments request
	ExploreSegments(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteStarredSegments request
	GetLoggedInAthleteStarredSegments(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSegmentById request
	GetSegmentById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StarSegmentWithBody request with any body
	StarSegmentWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StarSegmentWithFormdataBody(ctx context.Context, id int64, body StarSegmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSegmentStreams request
	GetSegmentStreams(ctx context.Context, id int64, params *GetSegmentStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUploadWithBody request with any body
	CreateUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUploadById request
	GetUploadById(ctx context.Context, uploadId int64, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateActivityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateActivityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateActivityWithFormdataBody(ctx context.Context, body CreateActivityFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateActivityRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityById(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityByIdWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityByIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityById(ctx context.Context, id int64, body UpdateActivityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityByIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommentsByActivityId(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentsByActivityIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKudoersByActivityId(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKudoersByActivityIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLapsByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLapsByActivityIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityStreams(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityStreamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZonesByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZonesByActivityIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthlete(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoggedInAthlete(ctx context.Context, params *UpdateLoggedInAthleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoggedInAthleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteActivities(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteClubs(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteClubsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteZones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteZonesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesByAthleteId(ctx context.Context, id int, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesByAthleteIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubActivitiesById(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubActivitiesByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubAdminsById(ctx context.Context, id int64, params *GetClubAdminsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubAdminsByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubMembersById(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubMembersByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGearById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGearByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRouteById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouteByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRouteAsGPX(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouteAsGPXRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRouteAsTCX(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouteAsTCXRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRouteStreams(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouteStreamsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEffortsBySegmentId(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEffortsBySegmentIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSegmentEffortById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSegmentEffortByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSegmentEffortStreams(ctx context.Context, id int64, params *GetSegmentEffortStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSegmentEffortStreamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExploreSegments(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExploreSegmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteStarredSegments(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteStarredSegmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSegmentById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSegmentByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarSegmentWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarSegmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarSegmentWithFormdataBody(ctx context.Context, id int64, body StarSegmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarSegmentRequestWithFormdataBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSegmentStreams(ctx context.Context, id int64, params *GetSegmentStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSegmentStreamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUploadById(ctx context.Context, uploadId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUploadByIdRequest(c.Server, uploadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateActivityRequestWithFormdataBody calls the generic CreateActivity builder with application/x-www-form-urlencoded body
func NewCreateActivityRequestWithFormdataBody(server string, body CreateActivityFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateActivityRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateActivityRequestWithBody generates requests for CreateActivity with any type of body
func NewCreateActivityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActivityByIdRequest generates requests for GetActivityById
func NewGetActivityByIdRequest(server string, id int64, params *GetActivityByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAllEfforts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_all_efforts", runtime.ParamLocationQuery, *params.IncludeAllEfforts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateActivityByIdRequest calls the generic UpdateActivityById builder with application/json body
func NewUpdateActivityByIdRequest(server string, id int64, body UpdateActivityByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateActivityByIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateActivityByIdRequestWithBody generates requests for UpdateActivityById with any type of body
func NewUpdateActivityByIdRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommentsByActivityIdRequest generates requests for GetCommentsByActivityId
func NewGetCommentsByActivityIdRequest(server string, id int64, params *GetCommentsByActivityIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_cursor", runtime.ParamLocationQuery, *params.AfterCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKudoersByActivityIdRequest generates requests for GetKudoersByActivityId
func NewGetKudoersByActivityIdRequest(server string, id int64, params *GetKudoersByActivityIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/kudos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLapsByActivityIdRequest generates requests for GetLapsByActivityId
func NewGetLapsByActivityIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/laps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityStreamsRequest generates requests for GetActivityStreams
func NewGetActivityStreamsRequest(server string, id int64, params *GetActivityStreamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/streams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "keys", runtime.ParamLocationQuery, params.Keys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key_by_type", runtime.ParamLocationQuery, params.KeyByType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetZonesByActivityIdRequest generates requests for GetZonesByActivityId
func NewGetZonesByActivityIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/zones", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteRequest generates requests for GetLoggedInAthlete
func NewGetLoggedInAthleteRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoggedInAthleteRequest generates requests for UpdateLoggedInAthlete
func NewUpdateLoggedInAthleteRequest(server string, params *UpdateLoggedInAthleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "weight", runtime.ParamLocationQuery, params.Weight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteActivitiesRequest generates requests for GetLoggedInAthleteActivities
func NewGetLoggedInAthleteActivitiesRequest(server string, params *GetLoggedInAthleteActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteClubsRequest generates requests for GetLoggedInAthleteClubs
func NewGetLoggedInAthleteClubsRequest(server string, params *GetLoggedInAthleteClubsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete/clubs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteZonesRequest generates requests for GetLoggedInAthleteZones
func NewGetLoggedInAthleteZonesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoutesByAthleteIdRequest generates requests for GetRoutesByAthleteId
func NewGetRoutesByAthleteIdRequest(server string, id int, params *GetRoutesByAthleteIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athletes/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athletes/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubByIdRequest generates requests for GetClubById
func NewGetClubByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubActivitiesByIdRequest generates requests for GetClubActivitiesById
func NewGetClubActivitiesByIdRequest(server string, id int64, params *GetClubActivitiesByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubAdminsByIdRequest generates requests for GetClubAdminsById
func NewGetClubAdminsByIdRequest(server string, id int64, params *GetClubAdminsByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubMembersByIdRequest generates requests for GetClubMembersById
func NewGetClubMembersByIdRequest(server string, id int64, params *GetClubMembersByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGearByIdRequest generates requests for GetGearById
func NewGetGearByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gear/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRouteByIdRequest generates requests for GetRouteById
func NewGetRouteByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRouteAsGPXRequest generates requests for GetRouteAsGPX
func NewGetRouteAsGPXRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/export_gpx", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRouteAsTCXRequest generates requests for GetRouteAsTCX
func NewGetRouteAsTCXRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/export_tcx", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRouteStreamsRequest generates requests for GetRouteStreams
func NewGetRouteStreamsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/streams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEffortsBySegmentIdRequest generates requests for GetEffortsBySegmentId
func NewGetEffortsBySegmentIdRequest(server string, params *GetEffortsBySegmentIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segment_efforts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segment_id", runtime.ParamLocationQuery, params.SegmentId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartDateLocal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date_local", runtime.ParamLocationQuery, *params.StartDateLocal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDateLocal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date_local", runtime.ParamLocationQuery, *params.EndDateLocal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSegmentEffortByIdRequest generates requests for GetSegmentEffortById
func NewGetSegmentEffortByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segment_efforts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSegmentEffortStreamsRequest generates requests for GetSegmentEffortStreams
func NewGetSegmentEffortStreamsRequest(server string, id int64, params *GetSegmentEffortStreamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segment_efforts/%s/streams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "keys", runtime.ParamLocationQuery, params.Keys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key_by_type", runtime.ParamLocationQuery, params.KeyByType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExploreSegmentsRequest generates requests for ExploreSegments
func NewExploreSegmentsRequest(server string, params *ExploreSegmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/explore")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bounds", runtime.ParamLocationQuery, params.Bounds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ActivityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activity_type", runtime.ParamLocationQuery, *params.ActivityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_cat", runtime.ParamLocationQuery, *params.MinCat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_cat", runtime.ParamLocationQuery, *params.MaxCat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteStarredSegmentsRequest generates requests for GetLoggedInAthleteStarredSegments
func NewGetLoggedInAthleteStarredSegmentsRequest(server string, params *GetLoggedInAthleteStarredSegmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/starred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSegmentByIdRequest generates requests for GetSegmentById
func NewGetSegmentByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStarSegmentRequestWithFormdataBody calls the generic StarSegment builder with application/x-www-form-urlencoded body
func NewStarSegmentRequestWithFormdataBody(server string, id int64, body StarSegmentFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStarSegmentRequestWithBody(server, id, "application/x-www-form-urlencoded", bodyReader)
}

// NewStarSegmentRequestWithBody generates requests for StarSegment with any type of body
func NewStarSegmentRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/%s/starred", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSegmentStreamsRequest generates requests for GetSegmentStreams
func NewGetSegmentStreamsRequest(server string, id int64, params *GetSegmentStreamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/%s/streams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "keys", runtime.ParamLocationQuery, params.Keys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key_by_type", runtime.ParamLocationQuery, params.KeyByType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUploadRequestWithBody generates requests for CreateUpload with any type of body
func NewCreateUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUploadByIdRequest generates requests for GetUploadById
func NewGetUploadByIdRequest(server string, uploadId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateActivityWithBodyWithResponse request with any body
	CreateActivityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateActivityResponse, error)

	CreateActivityWithFormdataBodyWithResponse(ctx context.Context, body CreateActivityFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateActivityResponse, error)

	// GetActivityByIdWithResponse request
	GetActivityByIdWithResponse(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*GetActivityByIdResponse, error)

	// UpdateActivityByIdWithBodyWithResponse request with any body
	UpdateActivityByIdWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityByIdResponse, error)

	UpdateActivityByIdWithResponse(ctx context.Context, id int64, body UpdateActivityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityByIdResponse, error)

	// GetCommentsByActivityIdWithResponse request
	GetCommentsByActivityIdWithResponse(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*GetCommentsByActivityIdResponse, error)

	// GetKudoersByActivityIdWithResponse request
	GetKudoersByActivityIdWithResponse(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*GetKudoersByActivityIdResponse, error)

	// GetLapsByActivityIdWithResponse request
	GetLapsByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetLapsByActivityIdResponse, error)

	// GetActivityStreamsWithResponse request
	GetActivityStreamsWithResponse(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*GetActivityStreamsResponse, error)

	// GetZonesByActivityIdWithResponse request
	GetZonesByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetZonesByActivityIdResponse, error)

	// GetLoggedInAthleteWithResponse request
	GetLoggedInAthleteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteResponse, error)

	// UpdateLoggedInAthleteWithResponse request
	UpdateLoggedInAthleteWithResponse(ctx context.Context, params *UpdateLoggedInAthleteParams, reqEditors ...RequestEditorFn) (*UpdateLoggedInAthleteResponse, error)

	// GetLoggedInAthleteActivitiesWithResponse request
	GetLoggedInAthleteActivitiesWithResponse(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteActivitiesResponse, error)

	// GetLoggedInAthleteClubsWithResponse request
	GetLoggedInAthleteClubsWithResponse(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteClubsResponse, error)

	// GetLoggedInAthleteZonesWithResponse request
	GetLoggedInAthleteZonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteZonesResponse, error)

	// GetRoutesByAthleteIdWithResponse request
	GetRoutesByAthleteIdWithResponse(ctx context.Context, id int, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*GetRoutesByAthleteIdResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetClubByIdWithResponse request
	GetClubByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetClubByIdResponse, error)

	// GetClubActivitiesByIdWithResponse request
	GetClubActivitiesByIdWithResponse(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*GetClubActivitiesByIdResponse, error)

	// GetClubAdminsByIdWithResponse request
	GetClubAdminsByIdWithResponse(ctx context.Context, id int64, params *GetClubAdminsByIdParams, reqEditors ...RequestEditorFn) (*GetClubAdminsByIdResponse, error)

	// GetClubMembersByIdWithResponse request
	GetClubMembersByIdWithResponse(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*GetClubMembersByIdResponse, error)

	// GetGearByIdWithResponse request
	GetGearByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGearByIdResponse, error)

	// GetRouteByIdWithResponse request
	GetRouteByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteByIdResponse, error)

	// GetRouteAsGPXWithResponse request
	GetRouteAsGPXWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteAsGPXResponse, error)

	// GetRouteAsTCXWithResponse request
	GetRouteAsTCXWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteAsTCXResponse, error)

	// GetRouteStreamsWithResponse request
	GetRouteStreamsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteStreamsResponse, error)

	// GetEffortsBySegmentIdWithResponse request
	GetEffortsBySegmentIdWithResponse(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*GetEffortsBySegmentIdResponse, error)

	// GetSegmentEffortByIdWithResponse request
	GetSegmentEffortByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentEffortByIdResponse, error)

	// GetSegmentEffortStreamsWithResponse request
	GetSegmentEffortStreamsWithResponse(ctx context.Context, id int64, params *GetSegmentEffortStreamsParams, reqEditors ...RequestEditorFn) (*GetSegmentEffortStreamsResponse, error)

	// ExploreSegmentsWithResponse request
	ExploreSegmentsWithResponse(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*ExploreSegmentsResponse, error)

	// GetLoggedInAthleteStarredSegmentsWithResponse request
	GetLoggedInAthleteStarredSegmentsWithResponse(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteStarredSegmentsResponse, error)

	// GetSegmentByIdWithResponse request
	GetSegmentByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentByIdResponse, error)

	// StarSegmentWithBodyWithResponse request with any body
	StarSegmentWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarSegmentResponse, error)

	StarSegmentWithFormdataBodyWithResponse(ctx context.Context, id int64, body StarSegmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*StarSegmentResponse, error)

	// GetSegmentStreamsWithResponse request
	GetSegmentStreamsWithResponse(ctx context.Context, id int64, params *GetSegmentStreamsParams, reqEditors ...RequestEditorFn) (*GetSegmentStreamsResponse, error)

	// CreateUploadWithBodyWithResponse request with any body
	CreateUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUploadResponse, error)

	// GetUploadByIdWithResponse request
	GetUploadByIdWithResponse(ctx context.Context, uploadId int64, reqEditors ...RequestEditorFn) (*GetUploadByIdResponse, error)
}

type CreateActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DetailedActivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedActivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetActivityByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateActivityByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedActivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateActivityByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateActivityByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentsByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ActivityId The identifier of the activity this comment is related to
		ActivityId *int64          `json:"activity_id,omitempty"`
		Athlete    *SummaryAthlete `json:"athlete,omitempty"`

		// CreatedAt The time at which this comment was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Id The unique identifier of this comment
		Id *int64 `json:"id,omitempty"`

		// Text The content of the comment
		Text *string `json:"text,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetCommentsByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentsByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKudoersByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SummaryAthlete
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKudoersByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKudoersByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLapsByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Lap
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLapsByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLapsByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamSet
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetActivityStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZonesByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomZones *bool `json:"custom_zones,omitempty"`

		// DistributionBuckets Stores the exclusive ranges representing zones and the time spent in each.
		DistributionBuckets *[]struct {
			// Max The maximum value in the range.
			Max *int `json:"max,omitempty"`

			// Min The minimum value in the range.
			Min *int `json:"min,omitempty"`

			// Time The number of seconds spent in this zone
			Time *int `json:"time,omitempty"`
		} `json:"distribution_buckets,omitempty"`
		Max         *int                         `json:"max,omitempty"`
		Points      *int                         `json:"points,omitempty"`
		Score       *int                         `json:"score,omitempty"`
		SensorBased *bool                        `json:"sensor_based,omitempty"`
		Type        *GetZonesByActivityId200Type `json:"type,omitempty"`
	}
	JSONDefault *Error
}
type GetZonesByActivityId200Type string

// Status returns HTTPResponse.Status
func (r GetZonesByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZonesByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedAthlete
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoggedInAthleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedAthlete
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateLoggedInAthleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoggedInAthleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SummaryActivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteClubsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SummaryClub
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteClubsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteClubsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Zones
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesByAthleteIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Route
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRoutesByAthleteIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesByAthleteIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AllRideTotals *ActivityTotal `json:"all_ride_totals,omitempty"`
		AllRunTotals  *ActivityTotal `json:"all_run_totals,omitempty"`
		AllSwimTotals *ActivityTotal `json:"all_swim_totals,omitempty"`

		// BiggestClimbElevationGain The highest climb ridden by the athlete.
		BiggestClimbElevationGain *float64 `json:"biggest_climb_elevation_gain,omitempty"`

		// BiggestRideDistance The longest distance ridden by the athlete.
		BiggestRideDistance *float64       `json:"biggest_ride_distance,omitempty"`
		RecentRideTotals    *ActivityTotal `json:"recent_ride_totals,omitempty"`
		RecentRunTotals     *ActivityTotal `json:"recent_run_totals,omitempty"`
		RecentSwimTotals    *ActivityTotal `json:"recent_swim_totals,omitempty"`
		YtdRideTotals       *ActivityTotal `json:"ytd_ride_totals,omitempty"`

		// YtdRunTotals The year to date run stats for the athlete.
		YtdRunTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"ytd_run_totals,omitempty"`
		YtdSwimTotals *ActivityTotal `json:"ytd_swim_totals,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedClub
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClubByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubActivitiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Athlete *MetaAthlete `json:"athlete,omitempty"`

		// Distance The activity's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The activity's elapsed time, in seconds
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// MovingTime The activity's moving time, in seconds
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the activity
		Name *string `json:"name,omitempty"`

		// SportType An enumeration of the types an activity may have.
		SportType *ActivityType `json:"sport_type,omitempty"`

		// TotalElevationGain The activity's total elevation gain.
		TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

		// Type An enumeration of the types an activity may have.
		Type *ActivityType `json:"type,omitempty"`

		// WorkoutType The activity's workout type
		WorkoutType *int `json:"workout_type,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetClubActivitiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubActivitiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubAdminsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SummaryAthlete
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClubAdminsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubAdminsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubMembersByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Admin Whether the athlete is a club admin.
		Admin *bool `json:"admin,omitempty"`

		// Firstname The athlete's first name.
		Firstname *string `json:"firstname,omitempty"`

		// Lastname The athlete's last initial.
		Lastname *string `json:"lastname,omitempty"`

		// Member The athlete's member status.
		Member *string `json:"member,omitempty"`

		// Owner Whether the athlete is club owner.
		Owner *bool `json:"owner,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetClubMembersByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubMembersByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGearByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedGear
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGearByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGearByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouteByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRouteByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouteByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouteAsGPXResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRouteAsGPXResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouteAsGPXResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouteAsTCXResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRouteAsTCXResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouteAsTCXResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouteStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamSet
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRouteStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouteStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEffortsBySegmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DetailedSegmentEffort
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEffortsBySegmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEffortsBySegmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSegmentEffortByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedSegmentEffort
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSegmentEffortByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSegmentEffortByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSegmentEffortStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamSet
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSegmentEffortStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSegmentEffortStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExploreSegmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Segments The set of segments matching an explorer request
		Segments *[]struct {
			// AvgGrade The segment's average grade, in percents
			AvgGrade *float32 `json:"avg_grade,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catÃ©gorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// ClimbCategoryDesc The description for the category of the climb
			ClimbCategoryDesc *ExploreSegments200SegmentsClimbCategoryDesc `json:"climb_category_desc,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevDifference The segments's evelation difference, in meters
			ElevDifference *float32 `json:"elev_difference,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *LatLng `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Points The polyline of the segment
			Points *string `json:"points,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *LatLng `json:"start_latlng,omitempty"`
		} `json:"segments,omitempty"`
	}
	JSONDefault *Error
}
type ExploreSegments200SegmentsClimbCategoryDesc string

// Status returns HTTPResponse.Status
func (r ExploreSegmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExploreSegmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteStarredSegmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SummarySegment
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteStarredSegmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteStarredSegmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSegmentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedSegment
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSegmentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSegmentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StarSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedSegment
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StarSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StarSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSegmentStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamSet
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSegmentStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSegmentStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Upload
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upload
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUploadByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateActivityWithBodyWithResponse request with arbitrary body returning *CreateActivityResponse
func (c *ClientWithResponses) CreateActivityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateActivityResponse, error) {
	rsp, err := c.CreateActivityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateActivityResponse(rsp)
}

func (c *ClientWithResponses) CreateActivityWithFormdataBodyWithResponse(ctx context.Context, body CreateActivityFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateActivityResponse, error) {
	rsp, err := c.CreateActivityWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateActivityResponse(rsp)
}

// GetActivityByIdWithResponse request returning *GetActivityByIdResponse
func (c *ClientWithResponses) GetActivityByIdWithResponse(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*GetActivityByIdResponse, error) {
	rsp, err := c.GetActivityById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityByIdResponse(rsp)
}

// UpdateActivityByIdWithBodyWithResponse request with arbitrary body returning *UpdateActivityByIdResponse
func (c *ClientWithResponses) UpdateActivityByIdWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityByIdResponse, error) {
	rsp, err := c.UpdateActivityByIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateActivityByIdWithResponse(ctx context.Context, id int64, body UpdateActivityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityByIdResponse, error) {
	rsp, err := c.UpdateActivityById(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityByIdResponse(rsp)
}

// GetCommentsByActivityIdWithResponse request returning *GetCommentsByActivityIdResponse
func (c *ClientWithResponses) GetCommentsByActivityIdWithResponse(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*GetCommentsByActivityIdResponse, error) {
	rsp, err := c.GetCommentsByActivityId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentsByActivityIdResponse(rsp)
}

// GetKudoersByActivityIdWithResponse request returning *GetKudoersByActivityIdResponse
func (c *ClientWithResponses) GetKudoersByActivityIdWithResponse(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*GetKudoersByActivityIdResponse, error) {
	rsp, err := c.GetKudoersByActivityId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKudoersByActivityIdResponse(rsp)
}

// GetLapsByActivityIdWithResponse request returning *GetLapsByActivityIdResponse
func (c *ClientWithResponses) GetLapsByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetLapsByActivityIdResponse, error) {
	rsp, err := c.GetLapsByActivityId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLapsByActivityIdResponse(rsp)
}

// GetActivityStreamsWithResponse request returning *GetActivityStreamsResponse
func (c *ClientWithResponses) GetActivityStreamsWithResponse(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*GetActivityStreamsResponse, error) {
	rsp, err := c.GetActivityStreams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityStreamsResponse(rsp)
}

// GetZonesByActivityIdWithResponse request returning *GetZonesByActivityIdResponse
func (c *ClientWithResponses) GetZonesByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetZonesByActivityIdResponse, error) {
	rsp, err := c.GetZonesByActivityId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZonesByActivityIdResponse(rsp)
}

// GetLoggedInAthleteWithResponse request returning *GetLoggedInAthleteResponse
func (c *ClientWithResponses) GetLoggedInAthleteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteResponse, error) {
	rsp, err := c.GetLoggedInAthlete(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteResponse(rsp)
}

// UpdateLoggedInAthleteWithResponse request returning *UpdateLoggedInAthleteResponse
func (c *ClientWithResponses) UpdateLoggedInAthleteWithResponse(ctx context.Context, params *UpdateLoggedInAthleteParams, reqEditors ...RequestEditorFn) (*UpdateLoggedInAthleteResponse, error) {
	rsp, err := c.UpdateLoggedInAthlete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoggedInAthleteResponse(rsp)
}

// GetLoggedInAthleteActivitiesWithResponse request returning *GetLoggedInAthleteActivitiesResponse
func (c *ClientWithResponses) GetLoggedInAthleteActivitiesWithResponse(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteActivitiesResponse, error) {
	rsp, err := c.GetLoggedInAthleteActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteActivitiesResponse(rsp)
}

// GetLoggedInAthleteClubsWithResponse request returning *GetLoggedInAthleteClubsResponse
func (c *ClientWithResponses) GetLoggedInAthleteClubsWithResponse(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteClubsResponse, error) {
	rsp, err := c.GetLoggedInAthleteClubs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteClubsResponse(rsp)
}

// GetLoggedInAthleteZonesWithResponse request returning *GetLoggedInAthleteZonesResponse
func (c *ClientWithResponses) GetLoggedInAthleteZonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteZonesResponse, error) {
	rsp, err := c.GetLoggedInAthleteZones(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteZonesResponse(rsp)
}

// GetRoutesByAthleteIdWithResponse request returning *GetRoutesByAthleteIdResponse
func (c *ClientWithResponses) GetRoutesByAthleteIdWithResponse(ctx context.Context, id int, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*GetRoutesByAthleteIdResponse, error) {
	rsp, err := c.GetRoutesByAthleteId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesByAthleteIdResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetClubByIdWithResponse request returning *GetClubByIdResponse
func (c *ClientWithResponses) GetClubByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetClubByIdResponse, error) {
	rsp, err := c.GetClubById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubByIdResponse(rsp)
}

// GetClubActivitiesByIdWithResponse request returning *GetClubActivitiesByIdResponse
func (c *ClientWithResponses) GetClubActivitiesByIdWithResponse(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*GetClubActivitiesByIdResponse, error) {
	rsp, err := c.GetClubActivitiesById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubActivitiesByIdResponse(rsp)
}

// GetClubAdminsByIdWithResponse request returning *GetClubAdminsByIdResponse
func (c *ClientWithResponses) GetClubAdminsByIdWithResponse(ctx context.Context, id int64, params *GetClubAdminsByIdParams, reqEditors ...RequestEditorFn) (*GetClubAdminsByIdResponse, error) {
	rsp, err := c.GetClubAdminsById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubAdminsByIdResponse(rsp)
}

// GetClubMembersByIdWithResponse request returning *GetClubMembersByIdResponse
func (c *ClientWithResponses) GetClubMembersByIdWithResponse(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*GetClubMembersByIdResponse, error) {
	rsp, err := c.GetClubMembersById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubMembersByIdResponse(rsp)
}

// GetGearByIdWithResponse request returning *GetGearByIdResponse
func (c *ClientWithResponses) GetGearByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGearByIdResponse, error) {
	rsp, err := c.GetGearById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGearByIdResponse(rsp)
}

// GetRouteByIdWithResponse request returning *GetRouteByIdResponse
func (c *ClientWithResponses) GetRouteByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteByIdResponse, error) {
	rsp, err := c.GetRouteById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouteByIdResponse(rsp)
}

// GetRouteAsGPXWithResponse request returning *GetRouteAsGPXResponse
func (c *ClientWithResponses) GetRouteAsGPXWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteAsGPXResponse, error) {
	rsp, err := c.GetRouteAsGPX(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouteAsGPXResponse(rsp)
}

// GetRouteAsTCXWithResponse request returning *GetRouteAsTCXResponse
func (c *ClientWithResponses) GetRouteAsTCXWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteAsTCXResponse, error) {
	rsp, err := c.GetRouteAsTCX(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouteAsTCXResponse(rsp)
}

// GetRouteStreamsWithResponse request returning *GetRouteStreamsResponse
func (c *ClientWithResponses) GetRouteStreamsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteStreamsResponse, error) {
	rsp, err := c.GetRouteStreams(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouteStreamsResponse(rsp)
}

// GetEffortsBySegmentIdWithResponse request returning *GetEffortsBySegmentIdResponse
func (c *ClientWithResponses) GetEffortsBySegmentIdWithResponse(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*GetEffortsBySegmentIdResponse, error) {
	rsp, err := c.GetEffortsBySegmentId(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEffortsBySegmentIdResponse(rsp)
}

// GetSegmentEffortByIdWithResponse request returning *GetSegmentEffortByIdResponse
func (c *ClientWithResponses) GetSegmentEffortByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentEffortByIdResponse, error) {
	rsp, err := c.GetSegmentEffortById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSegmentEffortByIdResponse(rsp)
}

// GetSegmentEffortStreamsWithResponse request returning *GetSegmentEffortStreamsResponse
func (c *ClientWithResponses) GetSegmentEffortStreamsWithResponse(ctx context.Context, id int64, params *GetSegmentEffortStreamsParams, reqEditors ...RequestEditorFn) (*GetSegmentEffortStreamsResponse, error) {
	rsp, err := c.GetSegmentEffortStreams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSegmentEffortStreamsResponse(rsp)
}

// ExploreSegmentsWithResponse request returning *ExploreSegmentsResponse
func (c *ClientWithResponses) ExploreSegmentsWithResponse(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*ExploreSegmentsResponse, error) {
	rsp, err := c.ExploreSegments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExploreSegmentsResponse(rsp)
}

// GetLoggedInAthleteStarredSegmentsWithResponse request returning *GetLoggedInAthleteStarredSegmentsResponse
func (c *ClientWithResponses) GetLoggedInAthleteStarredSegmentsWithResponse(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteStarredSegmentsResponse, error) {
	rsp, err := c.GetLoggedInAthleteStarredSegments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteStarredSegmentsResponse(rsp)
}

// GetSegmentByIdWithResponse request returning *GetSegmentByIdResponse
func (c *ClientWithResponses) GetSegmentByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentByIdResponse, error) {
	rsp, err := c.GetSegmentById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSegmentByIdResponse(rsp)
}

// StarSegmentWithBodyWithResponse request with arbitrary body returning *StarSegmentResponse
func (c *ClientWithResponses) StarSegmentWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarSegmentResponse, error) {
	rsp, err := c.StarSegmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarSegmentResponse(rsp)
}

func (c *ClientWithResponses) StarSegmentWithFormdataBodyWithResponse(ctx context.Context, id int64, body StarSegmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*StarSegmentResponse, error) {
	rsp, err := c.StarSegmentWithFormdataBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarSegmentResponse(rsp)
}

// GetSegmentStreamsWithResponse request returning *GetSegmentStreamsResponse
func (c *ClientWithResponses) GetSegmentStreamsWithResponse(ctx context.Context, id int64, params *GetSegmentStreamsParams, reqEditors ...RequestEditorFn) (*GetSegmentStreamsResponse, error) {
	rsp, err := c.GetSegmentStreams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSegmentStreamsResponse(rsp)
}

// CreateUploadWithBodyWithResponse request with arbitrary body returning *CreateUploadResponse
func (c *ClientWithResponses) CreateUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUploadResponse, error) {
	rsp, err := c.CreateUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUploadResponse(rsp)
}

// GetUploadByIdWithResponse request returning *GetUploadByIdResponse
func (c *ClientWithResponses) GetUploadByIdWithResponse(ctx context.Context, uploadId int64, reqEditors ...RequestEditorFn) (*GetUploadByIdResponse, error) {
	rsp, err := c.GetUploadById(ctx, uploadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadByIdResponse(rsp)
}

// ParseCreateActivityResponse parses an HTTP response from a CreateActivityWithResponse call
func ParseCreateActivityResponse(rsp *http.Response) (*CreateActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DetailedActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivityByIdResponse parses an HTTP response from a GetActivityByIdWithResponse call
func ParseGetActivityByIdResponse(rsp *http.Response) (*GetActivityByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateActivityByIdResponse parses an HTTP response from a UpdateActivityByIdWithResponse call
func ParseUpdateActivityByIdResponse(rsp *http.Response) (*UpdateActivityByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateActivityByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCommentsByActivityIdResponse parses an HTTP response from a GetCommentsByActivityIdWithResponse call
func ParseGetCommentsByActivityIdResponse(rsp *http.Response) (*GetCommentsByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentsByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ActivityId The identifier of the activity this comment is related to
			ActivityId *int64          `json:"activity_id,omitempty"`
			Athlete    *SummaryAthlete `json:"athlete,omitempty"`

			// CreatedAt The time at which this comment was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Id The unique identifier of this comment
			Id *int64 `json:"id,omitempty"`

			// Text The content of the comment
			Text *string `json:"text,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKudoersByActivityIdResponse parses an HTTP response from a GetKudoersByActivityIdWithResponse call
func ParseGetKudoersByActivityIdResponse(rsp *http.Response) (*GetKudoersByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKudoersByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SummaryAthlete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLapsByActivityIdResponse parses an HTTP response from a GetLapsByActivityIdWithResponse call
func ParseGetLapsByActivityIdResponse(rsp *http.Response) (*GetLapsByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLapsByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Lap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivityStreamsResponse parses an HTTP response from a GetActivityStreamsWithResponse call
func ParseGetActivityStreamsResponse(rsp *http.Response) (*GetActivityStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetZonesByActivityIdResponse parses an HTTP response from a GetZonesByActivityIdWithResponse call
func ParseGetZonesByActivityIdResponse(rsp *http.Response) (*GetZonesByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZonesByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomZones *bool `json:"custom_zones,omitempty"`

			// DistributionBuckets Stores the exclusive ranges representing zones and the time spent in each.
			DistributionBuckets *[]struct {
				// Max The maximum value in the range.
				Max *int `json:"max,omitempty"`

				// Min The minimum value in the range.
				Min *int `json:"min,omitempty"`

				// Time The number of seconds spent in this zone
				Time *int `json:"time,omitempty"`
			} `json:"distribution_buckets,omitempty"`
			Max         *int                         `json:"max,omitempty"`
			Points      *int                         `json:"points,omitempty"`
			Score       *int                         `json:"score,omitempty"`
			SensorBased *bool                        `json:"sensor_based,omitempty"`
			Type        *GetZonesByActivityId200Type `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteResponse parses an HTTP response from a GetLoggedInAthleteWithResponse call
func ParseGetLoggedInAthleteResponse(rsp *http.Response) (*GetLoggedInAthleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedAthlete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateLoggedInAthleteResponse parses an HTTP response from a UpdateLoggedInAthleteWithResponse call
func ParseUpdateLoggedInAthleteResponse(rsp *http.Response) (*UpdateLoggedInAthleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoggedInAthleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedAthlete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteActivitiesResponse parses an HTTP response from a GetLoggedInAthleteActivitiesWithResponse call
func ParseGetLoggedInAthleteActivitiesResponse(rsp *http.Response) (*GetLoggedInAthleteActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SummaryActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteClubsResponse parses an HTTP response from a GetLoggedInAthleteClubsWithResponse call
func ParseGetLoggedInAthleteClubsResponse(rsp *http.Response) (*GetLoggedInAthleteClubsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteClubsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SummaryClub
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteZonesResponse parses an HTTP response from a GetLoggedInAthleteZonesWithResponse call
func ParseGetLoggedInAthleteZonesResponse(rsp *http.Response) (*GetLoggedInAthleteZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Zones
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoutesByAthleteIdResponse parses an HTTP response from a GetRoutesByAthleteIdWithResponse call
func ParseGetRoutesByAthleteIdResponse(rsp *http.Response) (*GetRoutesByAthleteIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesByAthleteIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AllRideTotals *ActivityTotal `json:"all_ride_totals,omitempty"`
			AllRunTotals  *ActivityTotal `json:"all_run_totals,omitempty"`
			AllSwimTotals *ActivityTotal `json:"all_swim_totals,omitempty"`

			// BiggestClimbElevationGain The highest climb ridden by the athlete.
			BiggestClimbElevationGain *float64 `json:"biggest_climb_elevation_gain,omitempty"`

			// BiggestRideDistance The longest distance ridden by the athlete.
			BiggestRideDistance *float64       `json:"biggest_ride_distance,omitempty"`
			RecentRideTotals    *ActivityTotal `json:"recent_ride_totals,omitempty"`
			RecentRunTotals     *ActivityTotal `json:"recent_run_totals,omitempty"`
			RecentSwimTotals    *ActivityTotal `json:"recent_swim_totals,omitempty"`
			YtdRideTotals       *ActivityTotal `json:"ytd_ride_totals,omitempty"`

			// YtdRunTotals The year to date run stats for the athlete.
			YtdRunTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"ytd_run_totals,omitempty"`
			YtdSwimTotals *ActivityTotal `json:"ytd_swim_totals,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubByIdResponse parses an HTTP response from a GetClubByIdWithResponse call
func ParseGetClubByIdResponse(rsp *http.Response) (*GetClubByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedClub
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubActivitiesByIdResponse parses an HTTP response from a GetClubActivitiesByIdWithResponse call
func ParseGetClubActivitiesByIdResponse(rsp *http.Response) (*GetClubActivitiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubActivitiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Athlete *MetaAthlete `json:"athlete,omitempty"`

			// Distance The activity's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The activity's elapsed time, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// MovingTime The activity's moving time, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the activity
			Name *string `json:"name,omitempty"`

			// SportType An enumeration of the types an activity may have.
			SportType *ActivityType `json:"sport_type,omitempty"`

			// TotalElevationGain The activity's total elevation gain.
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

			// Type An enumeration of the types an activity may have.
			Type *ActivityType `json:"type,omitempty"`

			// WorkoutType The activity's workout type
			WorkoutType *int `json:"workout_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubAdminsByIdResponse parses an HTTP response from a GetClubAdminsByIdWithResponse call
func ParseGetClubAdminsByIdResponse(rsp *http.Response) (*GetClubAdminsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubAdminsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SummaryAthlete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubMembersByIdResponse parses an HTTP response from a GetClubMembersByIdWithResponse call
func ParseGetClubMembersByIdResponse(rsp *http.Response) (*GetClubMembersByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubMembersByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Admin Whether the athlete is a club admin.
			Admin *bool `json:"admin,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// Lastname The athlete's last initial.
			Lastname *string `json:"lastname,omitempty"`

			// Member The athlete's member status.
			Member *string `json:"member,omitempty"`

			// Owner Whether the athlete is club owner.
			Owner *bool `json:"owner,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGearByIdResponse parses an HTTP response from a GetGearByIdWithResponse call
func ParseGetGearByIdResponse(rsp *http.Response) (*GetGearByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGearByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedGear
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRouteByIdResponse parses an HTTP response from a GetRouteByIdWithResponse call
func ParseGetRouteByIdResponse(rsp *http.Response) (*GetRouteByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouteByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRouteAsGPXResponse parses an HTTP response from a GetRouteAsGPXWithResponse call
func ParseGetRouteAsGPXResponse(rsp *http.Response) (*GetRouteAsGPXResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouteAsGPXResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRouteAsTCXResponse parses an HTTP response from a GetRouteAsTCXWithResponse call
func ParseGetRouteAsTCXResponse(rsp *http.Response) (*GetRouteAsTCXResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouteAsTCXResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRouteStreamsResponse parses an HTTP response from a GetRouteStreamsWithResponse call
func ParseGetRouteStreamsResponse(rsp *http.Response) (*GetRouteStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouteStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEffortsBySegmentIdResponse parses an HTTP response from a GetEffortsBySegmentIdWithResponse call
func ParseGetEffortsBySegmentIdResponse(rsp *http.Response) (*GetEffortsBySegmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEffortsBySegmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DetailedSegmentEffort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSegmentEffortByIdResponse parses an HTTP response from a GetSegmentEffortByIdWithResponse call
func ParseGetSegmentEffortByIdResponse(rsp *http.Response) (*GetSegmentEffortByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSegmentEffortByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedSegmentEffort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSegmentEffortStreamsResponse parses an HTTP response from a GetSegmentEffortStreamsWithResponse call
func ParseGetSegmentEffortStreamsResponse(rsp *http.Response) (*GetSegmentEffortStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSegmentEffortStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExploreSegmentsResponse parses an HTTP response from a ExploreSegmentsWithResponse call
func ParseExploreSegmentsResponse(rsp *http.Response) (*ExploreSegmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExploreSegmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Segments The set of segments matching an explorer request
			Segments *[]struct {
				// AvgGrade The segment's average grade, in percents
				AvgGrade *float32 `json:"avg_grade,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catÃ©gorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// ClimbCategoryDesc The description for the category of the climb
				ClimbCategoryDesc *ExploreSegments200SegmentsClimbCategoryDesc `json:"climb_category_desc,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevDifference The segments's evelation difference, in meters
				ElevDifference *float32 `json:"elev_difference,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *LatLng `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Points The polyline of the segment
				Points *string `json:"points,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *LatLng `json:"start_latlng,omitempty"`
			} `json:"segments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteStarredSegmentsResponse parses an HTTP response from a GetLoggedInAthleteStarredSegmentsWithResponse call
func ParseGetLoggedInAthleteStarredSegmentsResponse(rsp *http.Response) (*GetLoggedInAthleteStarredSegmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteStarredSegmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SummarySegment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSegmentByIdResponse parses an HTTP response from a GetSegmentByIdWithResponse call
func ParseGetSegmentByIdResponse(rsp *http.Response) (*GetSegmentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSegmentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedSegment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStarSegmentResponse parses an HTTP response from a StarSegmentWithResponse call
func ParseStarSegmentResponse(rsp *http.Response) (*StarSegmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StarSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedSegment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSegmentStreamsResponse parses an HTTP response from a GetSegmentStreamsWithResponse call
func ParseGetSegmentStreamsResponse(rsp *http.Response) (*GetSegmentStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSegmentStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUploadResponse parses an HTTP response from a CreateUploadWithResponse call
func ParseCreateUploadResponse(rsp *http.Response) (*CreateUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Upload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUploadByIdResponse parses an HTTP response from a GetUploadByIdWithResponse call
func ParseGetUploadByIdResponse(rsp *http.Response) (*GetUploadByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
